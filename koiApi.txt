package koiApi

import (
	"context"
	"fmt"
	"os"
	"time"
)

// AlbumInterface defines methods for interacting with Album resources.
type AlbumInterface interface {
	Create(ctx context.Context, client Client) (*Album, error)                                            // HTTP POST /api/albums
	Delete(ctx context.Context, client Client, albumID ...ID) error                                       // HTTP DELETE /api/albums/{id}
	Get(ctx context.Context, client Client, albumID ...ID) (*Album, error)                                // HTTP GET /api/albums/{id}
	GetParent(ctx context.Context, client Client, albumID ...ID) (*Album, error)                          // HTTP GET /api/albums/{id}/parent
	IRI() string                                                                                          // /api/albums/{id}
	List(ctx context.Context, client Client) ([]*Album, error)                                            // HTTP GET /api/albums
	ListChildren(ctx context.Context, client Client, albumID ...ID) ([]*Album, error)                     // HTTP GET /api/albums/{id}/children
	ListPhotos(ctx context.Context, client Client, albumID ...ID) ([]*Photo, error)                       // HTTP GET /api/albums/{id}/photos
	Patch(ctx context.Context, client Client, albumID ...ID) (*Album, error)                              // HTTP PATCH /api/albums/{id}
	Update(ctx context.Context, client Client, albumID ...ID) (*Album, error)                             // HTTP PUT /api/albums/{id}
	UploadImage(ctx context.Context, client Client, file []byte, albumID ...ID) (*Album, error)           // HTTP POST /api/albums/{id}/image
	UploadImageByFile(ctx context.Context, client Client, filename string, albumID ...ID) (*Album, error) // HTTP POST /api/albums/{id}/image
}

// Album represents an album in Koillection, combining fields for JSON-LD and API interactions.
type Album struct {
	Context          *Context   `json:"@context,omitempty" access:"rw"`         // JSON-LD only
	_ID              ID         `json:"@id,omitempty" access:"ro"`              // JSON-LD only
	Type             string     `json:"@type,omitempty" access:"rw"`            // JSON-LD only
	ID               ID         `json:"id,omitempty" access:"ro"`               // Identifier
	Title            string     `json:"title" access:"rw"`                      // Album title
	Color            string     `json:"color,omitempty" access:"ro"`            // Color code
	Image            *string    `json:"image,omitempty" access:"ro"`            // Image URL
	Owner            *string    `json:"owner,omitempty" access:"ro"`            // Owner IRI
	Parent           *string    `json:"parent,omitempty" access:"rw"`           // Parent album IRI
	SeenCounter      int        `json:"seenCounter,omitempty" access:"ro"`      // View count
	Visibility       Visibility `json:"visibility,omitempty" access:"rw"`       // Visibility level
	ParentVisibility *string    `json:"parentVisibility,omitempty" access:"ro"` // Parent visibility
	FinalVisibility  Visibility `json:"finalVisibility,omitempty" access:"ro"`  // Effective visibility
	CreatedAt        time.Time  `json:"createdAt" access:"ro"`                  // Creation timestamp
	UpdatedAt        *time.Time `json:"updatedAt,omitempty" access:"ro"`        // Update timestamp
	File             *string    `json:"file,omitempty" access:"wo"`             // Image file data
	DeleteImage      *bool      `json:"deleteImage,omitempty" access:"wo"`      // Flag to delete image
}

// whichID
func (a *Album) whichID(albumID ...ID) ID {
	if len(albumID) > 0 {
		return albumID[0]
	}
	return a.ID
}

// Create
func (a *Album) Create(ctx context.Context, client Client) (*Album, error) {
	return client.CreateAlbum(ctx, a)
}

// Delete
func (a *Album) Delete(ctx context.Context, client Client, albumID ...ID) error {
	id := a.whichID(albumID...)
	return client.DeleteAlbum(ctx, id)
}

// Get
func (a *Album) Get(ctx context.Context, client Client, albumID ...ID) (*Album, error) {
	id := a.whichID(albumID...)
	return client.GetAlbum(ctx, id)
}

// GetParent
func (a *Album) GetParent(ctx context.Context, client Client, albumID ...ID) (*Album, error) {
	id := a.whichID(albumID...)
	return client.GetAlbumParent(ctx, id)
}

// IRI
func (a *Album) IRI() string {
	return fmt.Sprintf("/api/albums/%s", a.ID)
}

// List
func (a *Album) List(ctx context.Context, client Client) ([]*Album, error) {
	var allAlbums []*Album
	for page := 1; ; page++ {
		albums, err := client.ListAlbums(ctx, page)
		if err != nil {
			return nil, fmt.Errorf("failed to list albums on page %d: %w", page, err)
		}
		if len(albums) == 0 {
			break
		}
		allAlbums = append(allAlbums, albums...)
	}
	return allAlbums, nil
}

// ListChildren
func (a *Album) ListChildren(ctx context.Context, client Client, albumID ...ID) ([]*Album, error) {
	id := a.whichID(albumID...)
	var allChildren []*Album
	for page := 1; ; page++ {
		children, err := client.ListAlbumChildren(ctx, id, page)
		if err != nil {
			return nil, fmt.Errorf("failed to list child albums for ID %s on page %d: %w", id, page, err)
		}
		if len(children) == 0 {
			break
		}
		allChildren = append(allChildren, children...)
	}
	return allChildren, nil
}

// ListPhotos
func (a *Album) ListPhotos(ctx context.Context, client Client, albumID ...ID) ([]*Photo, error) {
	id := a.whichID(albumID...)
	var allPhotos []*Photo
	for page := 1; ; page++ {
		photos, err := client.ListAlbumPhotos(ctx, id, page)
		if err != nil {
			return nil, fmt.Errorf("failed to list photos for ID %s on page %d: %w", id, page, err)
		}
		if len(photos) == 0 {
			break
		}
		allPhotos = append(allPhotos, photos...)
	}
	return allPhotos, nil
}

// Patch
func (a *Album) Patch(ctx context.Context, client Client, albumID ...ID) (*Album, error) {
	id := a.whichID(albumID...)
	return client.PatchAlbum(ctx, id, a)
}

// Update
func (a *Album) Update(ctx context.Context, client Client, albumID ...ID) (*Album, error) {
	id := a.whichID(albumID...)
	return client.UpdateAlbum(ctx, id, a)
}

// UploadImage
func (a *Album) UploadImage(ctx context.Context, client Client, file []byte, albumID ...ID) (*Album, error) {
	id := a.whichID(albumID...)
	return client.UploadAlbumImage(ctx, id, file)
}

// UploadImageByFile
func (a *Album) UploadImageByFile(ctx context.Context, client Client, filename string, albumID ...ID) (*Album, error) {
	id := a.whichID(albumID...)
	file, err := os.ReadFile(filename)
	if err != nil {
		return nil, fmt.Errorf("failed to read file %s: %w", filename, err)
	}
	return client.UploadAlbumImage(ctx, id, file)
}
package koiApi

import (
	"context"
	"fmt"
	"time"
)

// ChoiceListInterface defines methods for interacting with ChoiceList resources.
type ChoiceListInterface interface {
	Create(ctx context.Context, client Client) (*ChoiceList, error)                     // HTTP POST /api/choice_lists
	Delete(ctx context.Context, client Client, choiceListID ...ID) error                // HTTP DELETE /api/choice_lists/{id}
	Get(ctx context.Context, client Client, choiceListID ...ID) (*ChoiceList, error)    // HTTP GET /api/choice_lists/{id}
	IRI() string                                                                        // /api/choice_lists/{id}
	List(ctx context.Context, client Client) ([]*ChoiceList, error)                     // HTTP GET /api/choice_lists
	Patch(ctx context.Context, client Client, choiceListID ...ID) (*ChoiceList, error)  // HTTP PATCH /api/choice_lists/{id}
	Update(ctx context.Context, client Client, choiceListID ...ID) (*ChoiceList, error) // HTTP PUT /api/choice_lists/{id}
}

// ChoiceList represents a choice list in Koillection, combining fields for JSON-LD and API interactions.
type ChoiceList struct {
	Context   *Context   `json:"@context,omitempty" access:"rw"`  // JSON-LD only
	_ID       ID         `json:"@id,omitempty" access:"ro"`       // JSON-LD only
	Type      string     `json:"@type,omitempty" access:"rw"`     // JSON-LD only
	ID        ID         `json:"id,omitempty" access:"ro"`        // Identifier
	Name      string     `json:"name" access:"rw"`                // Choice list name
	Choices   []string   `json:"choices" access:"rw"`             // List of choices
	Owner     *string    `json:"owner,omitempty" access:"ro"`     // Owner IRI
	CreatedAt time.Time  `json:"createdAt" access:"ro"`           // Creation timestamp
	UpdatedAt *time.Time `json:"updatedAt,omitempty" access:"ro"` // Update timestamp
}

// whichID
func (cl *ChoiceList) whichID(choiceListID ...ID) ID {
	if len(choiceListID) > 0 {
		return choiceListID[0]
	}
	return cl.ID
}

// Create
func (cl *ChoiceList) Create(ctx context.Context, client Client) (*ChoiceList, error) {
	return client.CreateChoiceList(ctx, cl)
}

// Delete
func (cl *ChoiceList) Delete(ctx context.Context, client Client, choiceListID ...ID) error {
	id := cl.whichID(choiceListID...)
	return client.DeleteChoiceList(ctx, id)
}

// Get
func (cl *ChoiceList) Get(ctx context.Context, client Client, choiceListID ...ID) (*ChoiceList, error) {
	id := cl.whichID(choiceListID...)
	return client.GetChoiceList(ctx, id)
}

// IRI
func (cl *ChoiceList) IRI() string {
	return fmt.Sprintf("/api/choice_lists/%s", cl.ID)
}

// List
func (cl *ChoiceList) List(ctx context.Context, client Client) ([]*ChoiceList, error) {
	var allChoiceLists []*ChoiceList
	for page := 1; ; page++ {
		choiceLists, err := client.ListChoiceLists(ctx, page)
		if err != nil {
			return nil, fmt.Errorf("failed to list choice lists on page %d: %w", page, err)
		}
		if len(choiceLists) == 0 {
			break
		}
		allChoiceLists = append(allChoiceLists, choiceLists...)
	}
	return allChoiceLists, nil
}

// Patch
func (cl *ChoiceList) Patch(ctx context.Context, client Client, choiceListID ...ID) (*ChoiceList, error) {
	id := cl.whichID(choiceListID...)
	return client.PatchChoiceList(ctx, id, cl)
}

// Update
func (cl *ChoiceList) Update(ctx context.Context, client Client, choiceListID ...ID) (*ChoiceList, error) {
	id := cl.whichID(choiceListID...)
	return client.UpdateChoiceList(ctx, id, cl)
}
package koiApi

import "context"

// Client defines the interface for interacting with the Koillection REST API.
type Client interface {
	CheckLogin(ctx context.Context, username, password string) (string, error)                 // HTTP POST /api/authentication_token
	GetMetrics(ctx context.Context) (*Metrics, error)                                          // HTTP GET /api/metrics
	CreateAlbum(ctx context.Context, album *Album) (*Album, error)                             // HTTP POST /api/albums
	GetAlbum(ctx context.Context, id ID) (*Album, error)                                       // HTTP GET /api/albums/{id}
	ListAlbums(ctx context.Context, page int) ([]*Album, error)                                // HTTP GET /api/albums
	UpdateAlbum(ctx context.Context, id ID, album *Album) (*Album, error)                      // HTTP PUT /api/albums/{id}
	PatchAlbum(ctx context.Context, id ID, album *Album) (*Album, error)                       // HTTP PATCH /api/albums/{id}
	DeleteAlbum(ctx context.Context, id ID) error                                              // HTTP DELETE /api/albums/{id}
	ListAlbumChildren(ctx context.Context, id ID, page int) ([]*Album, error)                  // HTTP GET /api/albums/{id}/children
	UploadAlbumImage(ctx context.Context, id ID, file []byte) (*Album, error)                  // HTTP POST /api/albums/{id}/image
	GetAlbumParent(ctx context.Context, id ID) (*Album, error)                                 // HTTP GET /api/albums/{id}/parent
	ListAlbumPhotos(ctx context.Context, id ID, page int) ([]*Photo, error)                    // HTTP GET /api/albums/{id}/photos
	CreateChoiceList(ctx context.Context, choiceList *ChoiceList) (*ChoiceList, error)         // HTTP POST /api/choice_lists
	GetChoiceList(ctx context.Context, id ID) (*ChoiceList, error)                             // HTTP GET /api/choice_lists/{id}
	ListChoiceLists(ctx context.Context, page int) ([]*ChoiceList, error)                      // HTTP GET /api/choice_lists
	UpdateChoiceList(ctx context.Context, id ID, choiceList *ChoiceList) (*ChoiceList, error)  // HTTP PUT /api/choice_lists/{id}
	PatchChoiceList(ctx context.Context, id ID, choiceList *ChoiceList) (*ChoiceList, error)   // HTTP PATCH /api/choice_lists/{id}
	DeleteChoiceList(ctx context.Context, id ID) error                                         // HTTP DELETE /api/choice_lists/{id}
	CreateCollection(ctx context.Context, collection *Collection) (*Collection, error)         // HTTP POST /api/collections
	GetCollection(ctx context.Context, id ID) (*Collection, error)                             // HTTP GET /api/collections/{id}
	ListCollections(ctx context.Context, page int) ([]*Collection, error)                      // HTTP GET /api/collections
	UpdateCollection(ctx context.Context, id ID, collection *Collection) (*Collection, error)  // HTTP PUT /api/collections/{id}
	PatchCollection(ctx context.Context, id ID, collection *Collection) (*Collection, error)   // HTTP PATCH /api/collections/{id}
	DeleteCollection(ctx context.Context, id ID) error                                         // HTTP DELETE /api/collections/{id}
	ListCollectionChildren(ctx context.Context, id ID, page int) ([]*Collection, error)        // HTTP GET /api/collections/{id}/children
	UploadCollectionImage(ctx context.Context, id ID, file []byte) (*Collection, error)        // HTTP POST /api/collections/{id}/image
	GetCollectionParent(ctx context.Context, id ID) (*Collection, error)                       // HTTP GET /api/collections/{id}/parent
	ListCollectionItems(ctx context.Context, id ID, page int) ([]*Item, error)                 // HTTP GET /api/collections/{id}/items
	ListCollectionData(ctx context.Context, id ID, page int) ([]*Datum, error)                 // HTTP GET /api/collections/{id}/data
	GetCollectionDefaultTemplate(ctx context.Context, id ID) (*Template, error)                // HTTP GET /api/collections/{id}/items_default_template
	CreateDatum(ctx context.Context, datum *Datum) (*Datum, error)                             // HTTP POST /api/data
	GetDatum(ctx context.Context, id ID) (*Datum, error)                                       // HTTP GET /api/data/{id}
	ListData(ctx context.Context, page int) ([]*Datum, error)                                  // HTTP GET /api/data
	UpdateDatum(ctx context.Context, id ID, datum *Datum) (*Datum, error)                      // HTTP PUT /api/data/{id}
	PatchDatum(ctx context.Context, id ID, datum *Datum) (*Datum, error)                       // HTTP PATCH /api/data/{id}
	DeleteDatum(ctx context.Context, id ID) error                                              // HTTP DELETE /api/data/{id}
	UploadDatumFile(ctx context.Context, id ID, file []byte) (*Datum, error)                   // HTTP POST /api/data/{id}/file
	UploadDatumImage(ctx context.Context, id ID, image []byte) (*Datum, error)                 // HTTP POST /api/data/{id}/image
	UploadDatumVideo(ctx context.Context, id ID, video []byte) (*Datum, error)                 // HTTP POST /api/data/{id}/video
	GetDatumItem(ctx context.Context, id ID) (*Item, error)                                    // HTTP GET /api/data/{id}/item
	GetDatumCollection(ctx context.Context, id ID) (*Collection, error)                        // HTTP GET /api/data/{id}/collection
	CreateField(ctx context.Context, field *Field) (*Field, error)                             // HTTP POST /api/fields
	GetField(ctx context.Context, id ID) (*Field, error)                                       // HTTP GET /api/fields/{id}
	ListFields(ctx context.Context, page int) ([]*Field, error)                                // HTTP GET /api/fields
	UpdateField(ctx context.Context, id ID, field *Field) (*Field, error)                      // HTTP PUT /api/fields/{id}
	PatchField(ctx context.Context, id ID, field *Field) (*Field, error)                       // HTTP PATCH /api/fields/{id}
	DeleteField(ctx context.Context, id ID) error                                              // HTTP DELETE /api/fields/{id}
	GetFieldTemplate(ctx context.Context, id ID) (*Template, error)                            // HTTP GET /api/fields/{id}/template
	ListTemplateFields(ctx context.Context, templateid ID, page int) ([]*Field, error)         // HTTP GET /api/templates/{id}/fields
	ListInventories(ctx context.Context, page int) ([]*Inventory, error)                       // HTTP GET /api/inventories
	GetInventory(ctx context.Context, id ID) (*Inventory, error)                               // HTTP GET /api/inventories/{id}
	DeleteInventory(ctx context.Context, id ID) error                                          // HTTP DELETE /api/inventories/{id}
	CreateItem(ctx context.Context, item *Item) (*Item, error)                                 // HTTP POST /api/items
	GetItem(ctx context.Context, id ID) (*Item, error)                                         // HTTP GET /api/items/{id}
	ListItems(ctx context.Context, page int) ([]*Item, error)                                  // HTTP GET /api/items
	UpdateItem(ctx context.Context, id ID, item *Item) (*Item, error)                          // HTTP PUT /api/items/{id}
	PatchItem(ctx context.Context, id ID, item *Item) (*Item, error)                           // HTTP PATCH /api/items/{id}
	DeleteItem(ctx context.Context, id ID) error                                               // HTTP DELETE /api/items/{id}
	UploadItemImage(ctx context.Context, id ID, file []byte) (*Item, error)                    // HTTP POST /api/items/{id}/image
	ListItemRelatedItems(ctx context.Context, id ID, page int) ([]*Item, error)                // HTTP GET /api/items/{id}/related_items
	ListItemLoans(ctx context.Context, id ID, page int) ([]*Loan, error)                       // HTTP GET /api/items/{id}/loans
	ListItemTags(ctx context.Context, id ID, page int) ([]*Tag, error)                         // HTTP GET /api/items/{id}/tags
	ListItemData(ctx context.Context, id ID, page int) ([]*Datum, error)                       // HTTP GET /api/items/{id}/data
	GetItemCollection(ctx context.Context, id ID) (*Collection, error)                         // HTTP GET /api/items/{id}/collection
	CreateLoan(ctx context.Context, loan *Loan) (*Loan, error)                                 // HTTP POST /api/loans
	GetLoan(ctx context.Context, id ID) (*Loan, error)                                         // HTTP GET /api/loans/{id}
	ListLoans(ctx context.Context, page int) ([]*Loan, error)                                  // HTTP GET /api/loans
	UpdateLoan(ctx context.Context, id ID, loan *Loan) (*Loan, error)                          // HTTP PUT /api/loans/{id}
	PatchLoan(ctx context.Context, id ID, loan *Loan) (*Loan, error)                           // HTTP PATCH /api/loans/{id}
	DeleteLoan(ctx context.Context, id ID) error                                               // HTTP DELETE /api/loans/{id}
	GetLoanItem(ctx context.Context, id ID) (*Item, error)                                     // HTTP GET /api/loans/{id}/item
	GetLog(ctx context.Context, id ID) (*Log, error)                                           // HTTP GET /api/logs/{id}
	ListLogs(ctx context.Context, page int) ([]*Log, error)                                    // HTTP GET /api/logs
	CreatePhoto(ctx context.Context, photo *Photo) (*Photo, error)                             // HTTP POST /api/photos
	GetPhoto(ctx context.Context, id ID) (*Photo, error)                                       // HTTP GET /api/photos/{id}
	ListPhotos(ctx context.Context, page int) ([]*Photo, error)                                // HTTP GET /api/photos
	UpdatePhoto(ctx context.Context, id ID, photo *Photo) (*Photo, error)                      // HTTP PUT /api/photos/{id}
	PatchPhoto(ctx context.Context, id ID, photo *Photo) (*Photo, error)                       // HTTP PATCH /api/photos/{id}
	DeletePhoto(ctx context.Context, id ID) error                                              // HTTP DELETE /api/photos/{id}
	UploadPhotoImage(ctx context.Context, id ID, file []byte) (*Photo, error)                  // HTTP POST /api/photos/{id}/image
	GetPhotoAlbum(ctx context.Context, id ID) (*Album, error)                                  // HTTP GET /api/photos/{id}/album
	CreateTag(ctx context.Context, tag *Tag) (*Tag, error)                                     // HTTP POST /api/tags
	GetTag(ctx context.Context, id ID) (*Tag, error)                                           // HTTP GET /api/tags/{id}
	ListTags(ctx context.Context, page int) ([]*Tag, error)                                    // HTTP GET /api/tags
	UpdateTag(ctx context.Context, id ID, tag *Tag) (*Tag, error)                              // HTTP PUT /api/tags/{id}
	PatchTag(ctx context.Context, id ID, tag *Tag) (*Tag, error)                               // HTTP PATCH /api/tags/{id}
	DeleteTag(ctx context.Context, id ID) error                                                // HTTP DELETE /api/tags/{id}
	UploadTagImage(ctx context.Context, id ID, file []byte) (*Tag, error)                      // HTTP POST /api/tags/{id}/image
	ListTagItems(ctx context.Context, id ID, page int) ([]*Item, error)                        // HTTP GET /api/tags/{id}/items
	GetCategoryOfTag(ctx context.Context, id ID) (*TagCategory, error)                         // HTTP GET /api/tags/{id}/category
	CreateTagCategory(ctx context.Context, category *TagCategory) (*TagCategory, error)        // HTTP POST /api/tag_categories
	GetTagCategory(ctx context.Context, id ID) (*TagCategory, error)                           // HTTP GET /api/tag_categories/{id}
	ListTagCategories(ctx context.Context, page int) ([]*TagCategory, error)                   // HTTP GET /api/tag_categories
	UpdateTagCategory(ctx context.Context, id ID, category *TagCategory) (*TagCategory, error) // HTTP PUT /api/tag_categories/{id}
	PatchTagCategory(ctx context.Context, id ID, category *TagCategory) (*TagCategory, error)  // HTTP PATCH /api/tag_categories/{id}
	DeleteTagCategory(ctx context.Context, id ID) error                                        // HTTP DELETE /api/tag_categories/{id}
	ListTagCategoryTags(ctx context.Context, id ID, page int) ([]*Tag, error)                  // HTTP GET /api/tag_categories/{id}/tags
	CreateTemplate(ctx context.Context, template *Template) (*Template, error)                 // HTTP POST /api/templates
	GetTemplate(ctx context.Context, id ID) (*Template, error)                                 // HTTP GET /api/templates/{id}
	ListTemplates(ctx context.Context, page int) ([]*Template, error)                          // HTTP GET /api/templates
	UpdateTemplate(ctx context.Context, id ID, template *Template) (*Template, error)          // HTTP PUT /api/templates/{id}
	PatchTemplate(ctx context.Context, id ID, template *Template) (*Template, error)           // HTTP PATCH /api/templates/{id}
	DeleteTemplate(ctx context.Context, id ID) error                                           // HTTP DELETE /api/templates/{id}
	GetUser(ctx context.Context, id ID) (*User, error)                                         // HTTP GET /api/users/{id}
	ListUsers(ctx context.Context, page int) ([]*User, error)                                  // HTTP GET /api/users
	CreateWish(ctx context.Context, wish *Wish) (*Wish, error)                                 // HTTP POST /api/wishes
	GetWish(ctx context.Context, id ID) (*Wish, error)                                         // HTTP GET /api/wishes/{id}
	ListWishes(ctx context.Context, page int) ([]*Wish, error)                                 // HTTP GET /api/wishes
	UpdateWish(ctx context.Context, id ID, wish *Wish) (*Wish, error)                          // HTTP PUT /api/wishes/{id}
	PatchWish(ctx context.Context, id ID, wish *Wish) (*Wish, error)                           // HTTP PATCH /api/wishes/{id}
	DeleteWish(ctx context.Context, id ID) error                                               // HTTP DELETE /api/wishes/{id}
	UploadWishImage(ctx context.Context, id ID, file []byte) (*Wish, error)                    // HTTP POST /api/wishes/{id}/image
	GetWishWishlist(ctx context.Context, id ID) (*Wishlist, error)                             // HTTP GET /api/wishes/{id}/wishlist
	CreateWishlist(ctx context.Context, wishlist *Wishlist) (*Wishlist, error)                 // HTTP POST /api/wishlists
	GetWishlist(ctx context.Context, id ID) (*Wishlist, error)                                 // HTTP GET /api/wishlists/{id}
	ListWishlists(ctx context.Context, page int) ([]*Wishlist, error)                          // HTTP GET /api/wishlists
	UpdateWishlist(ctx context.Context, id ID, wishlist *Wishlist) (*Wishlist, error)          // HTTP PUT /api/wishlists/{id}
	PatchWishlist(ctx context.Context, id ID, wishlist *Wishlist) (*Wishlist, error)           // HTTP PATCH /api/wishlists/{id}
	DeleteWishlist(ctx context.Context, id ID) error                                           // HTTP DELETE /api/wishlists/{id}
	ListWishlistWishes(ctx context.Context, id ID, page int) ([]*Wish, error)                  // HTTP GET /api/wishlists/{id}/wishes
	ListWishlistChildren(ctx context.Context, id ID, page int) ([]*Wishlist, error)            // HTTP GET /api/wishlists/{id}/children
	UploadWishlistImage(ctx context.Context, id ID, file []byte) (*Wishlist, error)            // HTTP POST /api/wishlists/{id}/image
	GetWishlistParent(ctx context.Context, id ID) (*Wishlist, error)                           // HTTP GET /api/wishlists/{id}/parent
	GetResponse(ctx context.Context) string
	PrintError(ctx context.Context)
	DeleteAllData(ctx context.Context) error
}

// GetMetrics retrieves system or user-specific metrics.
func (c *httpClient) GetMetrics(ctx context.Context) (*Metrics, error) {
	var metrics Metrics
	if err := c.getResource(ctx, "/api/metrics", &metrics); err != nil {
		return nil, err
	}
	return &metrics, nil
}

// CreateAlbum creates a new album.
func (c *httpClient) CreateAlbum(ctx context.Context, album *Album) (*Album, error) {
	var result Album
	if err := c.postResource(ctx, "/api/albums", album, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

// GetAlbum retrieves an album by its ID.
func (c *httpClient) GetAlbum(ctx context.Context, id ID) (*Album, error) {
	var album Album
	if err := c.getResource(ctx, "/api/albums/"+string(id), &album); err != nil {
		return nil, err
	}
	return &album, nil
}

// ListAlbums retrieves a list of albums.
func (c *httpClient) ListAlbums(ctx context.Context, page int) ([]*Album, error) {
	var albums []*Album
	if err := c.listResources(ctx, "/api/albums", page, &albums); err != nil {
		return nil, err
	}
	return albums, nil
}

// UpdateAlbum replaces an existing album.
func (c *httpClient) UpdateAlbum(ctx context.Context, id ID, album *Album) (*Album, error) {
	var result Album
	if err := c.putResource(ctx, "/api/albums/"+string(id), album, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

// PatchAlbum updates an existing album partially.
func (c *httpClient) PatchAlbum(ctx context.Context, id ID, album *Album) (*Album, error) {
	var result Album
	if err := c.patchResource(ctx, "/api/albums/"+string(id), album, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

// DeleteAlbum deletes an album by its ID.
func (c *httpClient) DeleteAlbum(ctx context.Context, id ID) error {
	return c.deleteResource(ctx, "/api/albums/"+string(id))
}

// ListAlbumChildren retrieves child albums of an album.
func (c *httpClient) ListAlbumChildren(ctx context.Context, id ID, page int) ([]*Album, error) {
	var albums []*Album
	if err := c.listResources(ctx, "/api/albums/"+string(id)+"/children", page, &albums); err != nil {
		return nil, err
	}
	return albums, nil
}

// UploadAlbumImage uploads an image for an album.
func (c *httpClient) UploadAlbumImage(ctx context.Context, id ID, file []byte) (*Album, error) {
	var album Album
	if err := c.uploadFile(ctx, "/api/albums/"+string(id)+"/image", file, "file", &album); err != nil {
		return nil, err
	}
	return &album, nil
}

// GetAlbumParent retrieves the parent album of an album.
func (c *httpClient) GetAlbumParent(ctx context.Context, id ID) (*Album, error) {
	var album Album
	if err := c.getResource(ctx, "/api/albums/"+string(id)+"/parent", &album); err != nil {
		return nil, err
	}
	return &album, nil
}

// ListAlbumPhotos retrieves photos in an album.
func (c *httpClient) ListAlbumPhotos(ctx context.Context, id ID, page int) ([]*Photo, error) {
	var photos []*Photo
	if err := c.listResources(ctx, "/api/albums/"+string(id)+"/photos", page, &photos); err != nil {
		return nil, err
	}
	return photos, nil
}

// CreateChoiceList creates a new choice list.
func (c *httpClient) CreateChoiceList(ctx context.Context, choiceList *ChoiceList) (*ChoiceList, error) {
	var result ChoiceList
	if err := c.postResource(ctx, "/api/choice_lists", choiceList, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

// GetChoiceList retrieves a choice list by its ID.
func (c *httpClient) GetChoiceList(ctx context.Context, id ID) (*ChoiceList, error) {
	var choiceList ChoiceList
	if err := c.getResource(ctx, "/api/choice_lists/"+string(id), &choiceList); err != nil {
		return nil, err
	}
	return &choiceList, nil
}

// ListChoiceLists retrieves a list of choice lists.
func (c *httpClient) ListChoiceLists(ctx context.Context, page int) ([]*ChoiceList, error) {
	var choiceLists []*ChoiceList
	if err := c.listResources(ctx, "/api/choice_lists", page, &choiceLists); err != nil {
		return nil, err
	}
	return choiceLists, nil
}

// UpdateChoiceList replaces an existing choice list.
func (c *httpClient) UpdateChoiceList(ctx context.Context, id ID, choiceList *ChoiceList) (*ChoiceList, error) {
	var result ChoiceList
	if err := c.putResource(ctx, "/api/choice_lists/"+string(id), choiceList, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

// PatchChoiceList updates an existing choice list partially.
func (c *httpClient) PatchChoiceList(ctx context.Context, id ID, choiceList *ChoiceList) (*ChoiceList, error) {
	var result ChoiceList
	if err := c.patchResource(ctx, "/api/choice_lists/"+string(id), choiceList, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

// DeleteChoiceList deletes a choice list by its ID.
func (c *httpClient) DeleteChoiceList(ctx context.Context, id ID) error {
	return c.deleteResource(ctx, "/api/choice_lists/"+string(id))
}

// CreateCollection creates a new collection.
func (c *httpClient) CreateCollection(ctx context.Context, collection *Collection) (*Collection, error) {
	var result Collection
	if err := c.postResource(ctx, "/api/collections", collection, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

// GetCollection retrieves a collection by its ID.
func (c *httpClient) GetCollection(ctx context.Context, id ID) (*Collection, error) {
	var collection Collection
	if err := c.getResource(ctx, "/api/collections/"+string(id), &collection); err != nil {
		return nil, err
	}
	return &collection, nil
}

// ListCollections retrieves a list of collections.
func (c *httpClient) ListCollections(ctx context.Context, page int) ([]*Collection, error) {
	var collections []*Collection
	if err := c.listResources(ctx, "/api/collections", page, &collections); err != nil {
		return nil, err
	}
	return collections, nil
}

// UpdateCollection replaces an existing collection.
func (c *httpClient) UpdateCollection(ctx context.Context, id ID, collection *Collection) (*Collection, error) {
	var result Collection
	if err := c.putResource(ctx, "/api/collections/"+string(id), collection, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

// PatchCollection updates an existing collection partially.
func (c *httpClient) PatchCollection(ctx context.Context, id ID, collection *Collection) (*Collection, error) {
	var result Collection
	if err := c.patchResource(ctx, "/api/collections/"+string(id), collection, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

// DeleteCollection deletes a collection by its ID.
func (c *httpClient) DeleteCollection(ctx context.Context, id ID) error {
	return c.deleteResource(ctx, "/api/collections/"+string(id))
}

// ListCollectionChildren retrieves child collections of a collection.
func (c *httpClient) ListCollectionChildren(ctx context.Context, id ID, page int) ([]*Collection, error) {
	var collections []*Collection
	if err := c.listResources(ctx, "/api/collections/"+string(id)+"/children", page, &collections); err != nil {
		return nil, err
	}
	return collections, nil
}

// UploadCollectionImage uploads an image for a collection.
func (c *httpClient) UploadCollectionImage(ctx context.Context, id ID, file []byte) (*Collection, error) {
	var collection Collection
	if err := c.uploadFile(ctx, "/api/collections/"+string(id)+"/image", file, "file", &collection); err != nil {
		return nil, err
	}
	return &collection, nil
}

// GetCollectionParent retrieves the parent collection of a collection.
func (c *httpClient) GetCollectionParent(ctx context.Context, id ID) (*Collection, error) {
	var collection Collection
	if err := c.getResource(ctx, "/api/collections/"+string(id)+"/parent", &collection); err != nil {
		return nil, err
	}
	return &collection, nil
}

// ListCollectionItems retrieves items in a collection.
func (c *httpClient) ListCollectionItems(ctx context.Context, id ID, page int) ([]*Item, error) {
	var items []*Item
	if err := c.listResources(ctx, "/api/collections/"+string(id)+"/items", page, &items); err != nil {
		return nil, err
	}
	return items, nil
}

// ListCollectionData retrieves data fields in a collection.
func (c *httpClient) ListCollectionData(ctx context.Context, id ID, page int) ([]*Datum, error) {
	var data []*Datum
	if err := c.listResources(ctx, "/api/collections/"+string(id)+"/data", page, &data); err != nil {
		return nil, err
	}
	return data, nil
}

// GetCollectionDefaultTemplate retrieves the default template for items in a collection.
func (c *httpClient) GetCollectionDefaultTemplate(ctx context.Context, id ID) (*Template, error) {
	var template Template
	if err := c.getResource(ctx, "/api/collections/"+string(id)+"/items_default_template", &template); err != nil {
		return nil, err
	}
	return &template, nil
}

// CreateDatum creates a new datum.
func (c *httpClient) CreateDatum(ctx context.Context, datum *Datum) (*Datum, error) {
	var result Datum
	if err := c.postResource(ctx, "/api/data", datum, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

// GetDatum retrieves a datum by its ID.
func (c *httpClient) GetDatum(ctx context.Context, id ID) (*Datum, error) {
	var datum Datum
	if err := c.getResource(ctx, "/api/data/"+string(id), &datum); err != nil {
		return nil, err
	}
	return &datum, nil
}

// ListData retrieves a list of data fields.
func (c *httpClient) ListData(ctx context.Context, page int) ([]*Datum, error) {
	var data []*Datum
	if err := c.listResources(ctx, "/api/data", page, &data); err != nil {
		return nil, err
	}
	return data, nil
}

// UpdateDatum replaces an existing datum.
func (c *httpClient) UpdateDatum(ctx context.Context, id ID, datum *Datum) (*Datum, error) {
	var result Datum
	if err := c.putResource(ctx, "/api/data/"+string(id), datum, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

// PatchDatum updates an existing datum partially.
func (c *httpClient) PatchDatum(ctx context.Context, id ID, datum *Datum) (*Datum, error) {
	var result Datum
	if err := c.patchResource(ctx, "/api/data/"+string(id), datum, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

// DeleteDatum deletes a datum by its ID.
func (c *httpClient) DeleteDatum(ctx context.Context, id ID) error {
	return c.deleteResource(ctx, "/api/data/"+string(id))
}

// UploadDatumFile uploads a file for a datum.
func (c *httpClient) UploadDatumFile(ctx context.Context, id ID, file []byte) (*Datum, error) {
	var datum Datum
	if err := c.uploadFile(ctx, "/api/data/"+string(id)+"/file", file, "fileFile", &datum); err != nil {
		return nil, err
	}
	return &datum, nil
}

// UploadDatumImage uploads an image for a datum.
func (c *httpClient) UploadDatumImage(ctx context.Context, id ID, image []byte) (*Datum, error) {
	var datum Datum
	if err := c.uploadFile(ctx, "/api/data/"+string(id)+"/image", image, "fileImage", &datum); err != nil {
		return nil, err
	}
	return &datum, nil
}

// UploadDatumVideo uploads a video for a datum.
func (c *httpClient) UploadDatumVideo(ctx context.Context, id ID, video []byte) (*Datum, error) {
	var datum Datum
	if err := c.uploadFile(ctx, "/api/data/"+string(id)+"/video", video, "fileVideo", &datum); err != nil {
		return nil, err
	}
	return &datum, nil
}

// GetDatumItem retrieves the item associated with a datum.
func (c *httpClient) GetDatumItem(ctx context.Context, id ID) (*Item, error) {
	var item Item
	if err := c.getResource(ctx, "/api/data/"+string(id)+"/item", &item); err != nil {
		return nil, err
	}
	return &item, nil
}

// GetDatumCollection retrieves the collection associated with a datum.
func (c *httpClient) GetDatumCollection(ctx context.Context, id ID) (*Collection, error) {
	var collection Collection
	if err := c.getResource(ctx, "/api/data/"+string(id)+"/collection", &collection); err != nil {
		return nil, err
	}
	return &collection, nil
}

// CreateField creates a new field.
func (c *httpClient) CreateField(ctx context.Context, field *Field) (*Field, error) {
	var result Field
	if err := c.postResource(ctx, "/api/fields", field, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

// GetField retrieves a field by its ID.
func (c *httpClient) GetField(ctx context.Context, id ID) (*Field, error) {
	var field Field
	if err := c.getResource(ctx, "/api/fields/"+string(id), &field); err != nil {
		return nil, err
	}
	return &field, nil
}

// ListFields retrieves a list of fields.
func (c *httpClient) ListFields(ctx context.Context, page int) ([]*Field, error) {
	var fields []*Field
	if err := c.listResources(ctx, "/api/fields", page, &fields); err != nil {
		return nil, err
	}
	return fields, nil
}

// UpdateField replaces an existing field.
func (c *httpClient) UpdateField(ctx context.Context, id ID, field *Field) (*Field, error) {
	var result Field
	if err := c.putResource(ctx, "/api/fields/"+string(id), field, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

// PatchField updates an existing field partially.
func (c *httpClient) PatchField(ctx context.Context, id ID, field *Field) (*Field, error) {
	var result Field
	if err := c.patchResource(ctx, "/api/fields/"+string(id), field, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

// DeleteField deletes a field by its ID.
func (c *httpClient) DeleteField(ctx context.Context, id ID) error {
	return c.deleteResource(ctx, "/api/fields/"+string(id))
}

// GetFieldTemplate retrieves the template associated with a field.
func (c *httpClient) GetFieldTemplate(ctx context.Context, id ID) (*Template, error) {
	var template Template
	if err := c.getResource(ctx, "/api/fields/"+string(id)+"/template", &template); err != nil {
		return nil, err
	}
	return &template, nil
}

// ListTemplateFields retrieves fields associated with a template.
func (c *httpClient) ListTemplateFields(ctx context.Context, templateid ID, page int) ([]*Field, error) {
	var fields []*Field
	if err := c.listResources(ctx, "/api/templates/"+string(templateid)+"/fields", page, &fields); err != nil {
		return nil, err
	}
	return fields, nil
}

// ListInventories retrieves a list of inventories.
func (c *httpClient) ListInventories(ctx context.Context, page int) ([]*Inventory, error) {
	var inventories []*Inventory
	if err := c.listResources(ctx, "/api/inventories", page, &inventories); err != nil {
		return nil, err
	}
	return inventories, nil
}

// GetInventory retrieves an inventory by its ID.
func (c *httpClient) GetInventory(ctx context.Context, id ID) (*Inventory, error) {
	var inventory Inventory
	if err := c.getResource(ctx, "/api/inventories/"+string(id), &inventory); err != nil {
		return nil, err
	}
	return &inventory, nil
}

// DeleteInventory deletes an inventory by its ID.
func (c *httpClient) DeleteInventory(ctx context.Context, id ID) error {
	return c.deleteResource(ctx, "/api/inventories/"+string(id))
}

// CreateItem creates a new item.
func (c *httpClient) CreateItem(ctx context.Context, item *Item) (*Item, error) {
	var result Item
	if err := c.postResource(ctx, "/api/items", item, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

// GetItem retrieves an item by its ID.
func (c *httpClient) GetItem(ctx context.Context, id ID) (*Item, error) {
	var item Item
	if err := c.getResource(ctx, "/api/items/"+string(id), &item); err != nil {
		return nil, err
	}
	return &item, nil
}

// ListItems retrieves a list of items.
func (c *httpClient) ListItems(ctx context.Context, page int) ([]*Item, error) {
	var items []*Item
	if err := c.listResources(ctx, "/api/items", page, &items); err != nil {
		return nil, err
	}
	return items, nil
}

// UpdateItem replaces an existing item.
func (c *httpClient) UpdateItem(ctx context.Context, id ID, item *Item) (*Item, error) {
	var result Item
	if err := c.putResource(ctx, "/api/items/"+string(id), item, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

// PatchItem updates an existing item partially.
func (c *httpClient) PatchItem(ctx context.Context, id ID, item *Item) (*Item, error) {
	var result Item
	if err := c.patchResource(ctx, "/api/items/"+string(id), item, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

// DeleteItem deletes an item by its ID.
func (c *httpClient) DeleteItem(ctx context.Context, id ID) error {
	return c.deleteResource(ctx, "/api/items/"+string(id))
}

// UploadItemImage uploads an image for an item.
func (c *httpClient) UploadItemImage(ctx context.Context, id ID, file []byte) (*Item, error) {
	var item Item
	if err := c.uploadFile(ctx, "/api/items/"+string(id)+"/image", file, "file", &item); err != nil {
		return nil, err
	}
	return &item, nil
}

// ListItemRelatedItems retrieves related items for an item.
func (c *httpClient) ListItemRelatedItems(ctx context.Context, id ID, page int) ([]*Item, error) {
	var items []*Item
	if err := c.listResources(ctx, "/api/items/"+string(id)+"/related_items", page, &items); err != nil {
		return nil, err
	}
	return items, nil
}

// ListItemLoans retrieves loans for an item.
func (c *httpClient) ListItemLoans(ctx context.Context, id ID, page int) ([]*Loan, error) {
	var loans []*Loan
	if err := c.listResources(ctx, "/api/items/"+string(id)+"/loans", page, &loans); err != nil {
		return nil, err
	}
	return loans, nil
}

// ListItemTags retrieves tags for an item.
func (c *httpClient) ListItemTags(ctx context.Context, id ID, page int) ([]*Tag, error) {
	var tags []*Tag
	if err := c.listResources(ctx, "/api/items/"+string(id)+"/tags", page, &tags); err != nil {
		return nil, err
	}
	return tags, nil
}

// ListItemData retrieves data fields for an item.
func (c *httpClient) ListItemData(ctx context.Context, id ID, page int) ([]*Datum, error) {
	var data []*Datum
	if err := c.listResources(ctx, "/api/items/"+string(id)+"/data", page, &data); err != nil {
		return nil, err
	}
	return data, nil
}

// GetItemCollection retrieves the collection associated with an item.
func (c *httpClient) GetItemCollection(ctx context.Context, id ID) (*Collection, error) {
	var collection Collection
	if err := c.getResource(ctx, "/api/items/"+string(id)+"/collection", &collection); err != nil {
		return nil, err
	}
	return &collection, nil
}

// CreateLoan creates a new loan.
func (c *httpClient) CreateLoan(ctx context.Context, loan *Loan) (*Loan, error) {
	var result Loan
	if err := c.postResource(ctx, "/api/loans", loan, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

// GetLoan retrieves a loan by its ID.
func (c *httpClient) GetLoan(ctx context.Context, id ID) (*Loan, error) {
	var loan Loan
	if err := c.getResource(ctx, "/api/loans/"+string(id), &loan); err != nil {
		return nil, err
	}
	return &loan, nil
}

// ListLoans retrieves a list of loans.
func (c *httpClient) ListLoans(ctx context.Context, page int) ([]*Loan, error) {
	var loans []*Loan
	if err := c.listResources(ctx, "/api/loans", page, &loans); err != nil {
		return nil, err
	}
	return loans, nil
}

// UpdateLoan replaces(an existing loan.
func (c *httpClient) UpdateLoan(ctx context.Context, id ID, loan *Loan) (*Loan, error) {
	var result Loan
	if err := c.putResource(ctx, "/api/loans/"+string(id), loan, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

// PatchLoan updates an existing loan partially.
func (c *httpClient) PatchLoan(ctx context.Context, id ID, loan *Loan) (*Loan, error) {
	var result Loan
	if err := c.patchResource(ctx, "/api/loans/"+string(id), loan, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

// DeleteLoan deletes a loan by its ID.
func (c *httpClient) DeleteLoan(ctx context.Context, id ID) error {
	return c.deleteResource(ctx, "/api/loans/"+string(id))
}

// GetLoanItem retrieves the item associated with a loan.
func (c *httpClient) GetLoanItem(ctx context.Context, id ID) (*Item, error) {
	var item Item
	if err := c.getResource(ctx, "/api/loans/"+string(id)+"/item", &item); err != nil {
		return nil, err
	}
	return &item, nil
}

// GetLog retrieves a log by its ID.
func (c *httpClient) GetLog(ctx context.Context, id ID) (*Log, error) {
	var log Log
	if err := c.getResource(ctx, "/api/logs/"+string(id), &log); err != nil {
		return nil, err
	}
	return &log, nil
}

// ListLogs retrieves a list of logs.
func (c *httpClient) ListLogs(ctx context.Context, page int) ([]*Log, error) {
	var logs []*Log
	if err := c.listResources(ctx, "/api/logs", page, &logs); err != nil {
		return nil, err
	}
	return logs, nil
}

// CreatePhoto creates a new photo.
func (c *httpClient) CreatePhoto(ctx context.Context, photo *Photo) (*Photo, error) {
	var result Photo
	if err := c.postResource(ctx, "/api/photos", photo, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

// GetPhoto retrieves a photo by its ID.
func (c *httpClient) GetPhoto(ctx context.Context, id ID) (*Photo, error) {
	var photo Photo
	if err := c.getResource(ctx, "/api/photos/"+string(id), &photo); err != nil {
		return nil, err
	}
	return &photo, nil
}

// ListPhotos retrieves a list of photos.
func (c *httpClient) ListPhotos(ctx context.Context, page int) ([]*Photo, error) {
	var photos []*Photo
	if err := c.listResources(ctx, "/api/photos", page, &photos); err != nil {
		return nil, err
	}
	return photos, nil
}

// UpdatePhoto replaces an existing photo.
func (c *httpClient) UpdatePhoto(ctx context.Context, id ID, photo *Photo) (*Photo, error) {
	var result Photo
	if err := c.putResource(ctx, "/api/photos/"+string(id), photo, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

// PatchPhoto updates an existing photo partially.
func (c *httpClient) PatchPhoto(ctx context.Context, id ID, photo *Photo) (*Photo, error) {
	var result Photo
	if err := c.patchResource(ctx, "/api/photos/"+string(id), photo, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

// DeletePhoto deletes a photo by its ID.
func (c *httpClient) DeletePhoto(ctx context.Context, id ID) error {
	return c.deleteResource(ctx, "/api/photos/"+string(id))
}

// UploadPhotoImage uploads an image for a photo.
func (c *httpClient) UploadPhotoImage(ctx context.Context, id ID, file []byte) (*Photo, error) {
	var photo Photo
	if err := c.uploadFile(ctx, "/api/photos/"+string(id)+"/image", file, "file", &photo); err != nil {
		return nil, err
	}
	return &photo, nil
}

// GetPhotoAlbum retrieves the album associated with a photo.
func (c *httpClient) GetPhotoAlbum(ctx context.Context, id ID) (*Album, error) {
	var album Album
	if err := c.getResource(ctx, "/api/photos/"+string(id)+"/album", &album); err != nil {
		return nil, err
	}
	return &album, nil
}

// CreateTag creates a new tag.
func (c *httpClient) CreateTag(ctx context.Context, tag *Tag) (*Tag, error) {
	var result Tag
	if err := c.postResource(ctx, "/api/tags", tag, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

// GetTag retrieves a tag by its ID.
func (c *httpClient) GetTag(ctx context.Context, id ID) (*Tag, error) {
	var tag Tag
	if err := c.getResource(ctx, "/api/tags/"+string(id), &tag); err != nil {
		return nil, err
	}
	return &tag, nil
}

// ListTags retrieves a list of tags.
func (c *httpClient) ListTags(ctx context.Context, page int) ([]*Tag, error) {
	var tags []*Tag
	if err := c.listResources(ctx, "/api/tags", page, &tags); err != nil {
		return nil, err
	}
	return tags, nil
}

// UpdateTag replaces an existing tag.
func (c *httpClient) UpdateTag(ctx context.Context, id ID, tag *Tag) (*Tag, error) {
	var result Tag
	if err := c.putResource(ctx, "/api/tags/"+string(id), tag, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

// PatchTag updates an existing tag partially.
func (c *httpClient) PatchTag(ctx context.Context, id ID, tag *Tag) (*Tag, error) {
	var result Tag
	if err := c.patchResource(ctx, "/api/tags/"+string(id), tag, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

// DeleteTag deletes a tag by its ID.
func (c *httpClient) DeleteTag(ctx context.Context, id ID) error {
	return c.deleteResource(ctx, "/api/tags/"+string(id))
}

// UploadTagImage uploads an image for a tag.
func (c *httpClient) UploadTagImage(ctx context.Context, id ID, file []byte) (*Tag, error) {
	var tag Tag
	if err := c.uploadFile(ctx, "/api/tags/"+string(id)+"/image", file, "file", &tag); err != nil {
		return nil, err
	}
	return &tag, nil
}

// ListTagItems retrieves items associated with a tag.
func (c *httpClient) ListTagItems(ctx context.Context, id ID, page int) ([]*Item, error) {
	var items []*Item
	if err := c.listResources(ctx, "/api/tags/"+string(id)+"/items", page, &items); err != nil {
		return nil, err
	}
	return items, nil
}

// GetCategoryOfTag retrieves the category associated with a tag.
func (c *httpClient) GetCategoryOfTag(ctx context.Context, id ID) (*TagCategory, error) {
	var category TagCategory
	if err := c.getResource(ctx, "/api/tags/"+string(id)+"/category", &category); err != nil {
		return nil, err
	}
	return &category, nil
}

// CreateTagCategory creates a new tag category.
func (c *httpClient) CreateTagCategory(ctx context.Context, category *TagCategory) (*TagCategory, error) {
	var result TagCategory
	if err := c.postResource(ctx, "/api/tag_categories", category, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

// GetTagCategory retrieves a tag category by its ID.
func (c *httpClient) GetTagCategory(ctx context.Context, id ID) (*TagCategory, error) {
	var category TagCategory
	if err := c.getResource(ctx, "/api/tag_categories/"+string(id), &category); err != nil {
		return nil, err
	}
	return &category, nil
}

// ListTagCategories retrieves a list of tag categories.
func (c *httpClient) ListTagCategories(ctx context.Context, page int) ([]*TagCategory, error) {
	var categories []*TagCategory
	if err := c.listResources(ctx, "/api/tag_categories", page, &categories); err != nil {
		return nil, err
	}
	return categories, nil
}

// UpdateTagCategory replaces an existing tag category.
func (c *httpClient) UpdateTagCategory(ctx context.Context, id ID, category *TagCategory) (*TagCategory, error) {
	var result TagCategory
	if err := c.putResource(ctx, "/api/tag_categories/"+string(id), category, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

// PatchTagCategory updates an existing tag category partially.
func (c *httpClient) PatchTagCategory(ctx context.Context, id ID, category *TagCategory) (*TagCategory, error) {
	var result TagCategory
	if err := c.patchResource(ctx, "/api/tag_categories/"+string(id), category, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

// DeleteTagCategory deletes a tag category by its ID.
func (c *httpClient) DeleteTagCategory(ctx context.Context, id ID) error {
	return c.deleteResource(ctx, "/api/tag_categories/"+string(id))
}

// ListTagCategoryTags retrieves tags in a tag category.
func (c *httpClient) ListTagCategoryTags(ctx context.Context, id ID, page int) ([]*Tag, error) {
	var tags []*Tag
	if err := c.listResources(ctx, "/api/tag_categories/"+string(id)+"/tags", page, &tags); err != nil {
		return nil, err
	}
	return tags, nil
}

// CreateTemplate creates a new template.
func (c *httpClient) CreateTemplate(ctx context.Context, template *Template) (*Template, error) {
	var result Template
	if err := c.postResource(ctx, "/api/templates", template, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

// GetTemplate retrieves a template by its ID.
func (c *httpClient) GetTemplate(ctx context.Context, id ID) (*Template, error) {
	var template Template
	if err := c.getResource(ctx, "/api/templates/"+string(id), &template); err != nil {
		return nil, err
	}
	return &template, nil
}

// ListTemplates retrieves a list of templates.
func (c *httpClient) ListTemplates(ctx context.Context, page int) ([]*Template, error) {
	var templates []*Template
	if err := c.listResources(ctx, "/api/templates", page, &templates); err != nil {
		return nil, err
	}
	return templates, nil
}

// UpdateTemplate replaces an existing template.
func (c *httpClient) UpdateTemplate(ctx context.Context, id ID, template *Template) (*Template, error) {
	var result Template
	if err := c.putResource(ctx, "/api/templates/"+string(id), template, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

// PatchTemplate updates an existing template partially.
func (c *httpClient) PatchTemplate(ctx context.Context, id ID, template *Template) (*Template, error) {
	var result Template
	if err := c.patchResource(ctx, "/api/templates/"+string(id), template, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

// DeleteTemplate deletes a template by its ID.
func (c *httpClient) DeleteTemplate(ctx context.Context, id ID) error {
	return c.deleteResource(ctx, "/api/templates/"+string(id))
}

// GetUser retrieves a user by its ID.
func (c *httpClient) GetUser(ctx context.Context, id ID) (*User, error) {
	var user User
	if err := c.getResource(ctx, "/api/users/"+string(id), &user); err != nil {
		return nil, err
	}
	return &user, nil
}

// ListUsers retrieves a list of users.
func (c *httpClient) ListUsers(ctx context.Context, page int) ([]*User, error) {
	var users []*User
	if err := c.listResources(ctx, "/api/users", page, &users); err != nil {
		return nil, err
	}
	return users, nil
}

// CreateWish creates a new wish.
func (c *httpClient) CreateWish(ctx context.Context, wish *Wish) (*Wish, error) {
	var result Wish
	if err := c.postResource(ctx, "/api/wishes", wish, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

// GetWish retrieves a wish by its ID.
func (c *httpClient) GetWish(ctx context.Context, id ID) (*Wish, error) {
	var wish Wish
	if err := c.getResource(ctx, "/api/wishes/"+string(id), &wish); err != nil {
		return nil, err
	}
	return &wish, nil
}

// ListWishes retrieves a list of wishes.
func (c *httpClient) ListWishes(ctx context.Context, page int) ([]*Wish, error) {
	var wishes []*Wish
	if err := c.listResources(ctx, "/api/wishes", page, &wishes); err != nil {
		return nil, err
	}
	return wishes, nil
}

// UpdateWish replaces an existing wish.
func (c *httpClient) UpdateWish(ctx context.Context, id ID, wish *Wish) (*Wish, error) {
	var result Wish
	if err := c.putResource(ctx, "/api/wishes/"+string(id), wish, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

// PatchWish updates an existing wish partially.
func (c *httpClient) PatchWish(ctx context.Context, id ID, wish *Wish) (*Wish, error) {
	var result Wish
	if err := c.patchResource(ctx, "/api/wishes/"+string(id), wish, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

// DeleteWish deletes a wish by its ID.
func (c *httpClient) DeleteWish(ctx context.Context, id ID) error {
	return c.deleteResource(ctx, "/api/wishes/"+string(id))
}

// UploadWishImage uploads an image for a wish.
func (c *httpClient) UploadWishImage(ctx context.Context, id ID, file []byte) (*Wish, error) {
	var wish Wish
	if err := c.uploadFile(ctx, "/api/wishes/"+string(id)+"/image", file, "file", &wish); err != nil {
		return nil, err
	}
	return &wish, nil
}

// GetWishWishlist retrieves the wishlist associated with a wish.
func (c *httpClient) GetWishWishlist(ctx context.Context, id ID) (*Wishlist, error) {
	var wishlist Wishlist
	if err := c.getResource(ctx, "/api/wishes/"+string(id)+"/wishlist", &wishlist); err != nil {
		return nil, err
	}
	return &wishlist, nil
}

// CreateWishlist creates a new wishlist.
func (c *httpClient) CreateWishlist(ctx context.Context, wishlist *Wishlist) (*Wishlist, error) {
	var result Wishlist
	if err := c.postResource(ctx, "/api/wishlists", wishlist, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

// GetWishlist retrieves a wishlist by its ID.
func (c *httpClient) GetWishlist(ctx context.Context, id ID) (*Wishlist, error) {
	var wishlist Wishlist
	if err := c.getResource(ctx, "/api/wishlists/"+string(id), &wishlist); err != nil {
		return nil, err
	}
	return &wishlist, nil
}

// ListWishlists retrieves a list of wishlists.
func (c *httpClient) ListWishlists(ctx context.Context, page int) ([]*Wishlist, error) {
	var wishlists []*Wishlist
	if err := c.listResources(ctx, "/api/wishlists", page, &wishlists); err != nil {
		return nil, err
	}
	return wishlists, nil
}

// UpdateWishlist replaces an existing wishlist.
func (c *httpClient) UpdateWishlist(ctx context.Context, id ID, wishlist *Wishlist) (*Wishlist, error) {
	var result Wishlist
	if err := c.putResource(ctx, "/api/wishlists/"+string(id), wishlist, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

// PatchWishlist updates an existing wishlist partially.
func (c *httpClient) PatchWishlist(ctx context.Context, id ID, wishlist *Wishlist) (*Wishlist, error) {
	var result Wishlist
	if err := c.patchResource(ctx, "/api/wishlists/"+string(id), wishlist, &result); err != nil {
		return nil, err
	}
	return &result, nil
}

// DeleteWishlist deletes a wishlist by its ID.
func (c *httpClient) DeleteWishlist(ctx context.Context, id ID) error {
	return c.deleteResource(ctx, "/api/wishlists/"+string(id))
}

// ListWishlistWishes retrieves wishes in a wishlist.
func (c *httpClient) ListWishlistWishes(ctx context.Context, id ID, page int) ([]*Wish, error) {
	var wishes []*Wish
	if err := c.listResources(ctx, "/api/wishlists/"+string(id)+"/wishes", page, &wishes); err != nil {
		return nil, err
	}
	return wishes, nil
}

// ListWishlistChildren retrieves child wishlists of a wishlist.
func (c *httpClient) ListWishlistChildren(ctx context.Context, id ID, page int) ([]*Wishlist, error) {
	var wishlists []*Wishlist
	if err := c.listResources(ctx, "/api/wishlists/"+string(id)+"/children", page, &wishlists); err != nil {
		return nil, err
	}
	return wishlists, nil
}

// UploadWishlistImage uploads an image for a wishlist.
func (c *httpClient) UploadWishlistImage(ctx context.Context, id ID, file []byte) (*Wishlist, error) {
	var wishlist Wishlist
	if err := c.uploadFile(ctx, "/api/wishlists/"+string(id)+"/image", file, "file", &wishlist); err != nil {
		return nil, err
	}
	return &wishlist, nil
}

// GetWishlistParent retrieves the parent wishlist of a wishlist.
func (c *httpClient) GetWishlistParent(ctx context.Context, id ID) (*Wishlist, error) {
	var wishlist Wishlist
	if err := c.getResource(ctx, "/api/wishlists/"+string(id)+"/parent", &wishlist); err != nil {
		return nil, err
	}
	return &wishlist, nil
}
package koiApi

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"mime/multipart"
	"net/http"
	"net/http/cookiejar"
	"net/url"
	"strconv"
	"strings"
	"time"
)

// Errors for common HTTP status codes.
var (
	ErrInvalidInput  = errors.New("invalid input")
	ErrNotFound      = errors.New("resource not found")
	ErrUnprocessable = errors.New("unprocessable entity")
	ErrUnauthorized  = errors.New("unauthorized")
)

// KoiError represents a union of the 400 and 422 error response structures.
type KoiError struct {
	Context     string      `json:"@context,omitempty"`
	ID          string      `json:"@id,omitempty"`
	Type        string      `json:"@type,omitempty"`
	Title       string      `json:"title,omitempty"`
	Detail      string      `json:"detail,omitempty"`
	Status      int         `json:"status,omitempty"`
	Instance    string      `json:"instance,omitempty"`
	Description string      `json:"description,omitempty"`
	Violations  []Violation `json:"violations,omitempty"`
}

// Violation represents a single violation in a 422 error response.
type Violation struct {
	PropertyPath string `json:"propertyPath"`
	Message      string `json:"message"`
}

// httpClient implements the Client interface using net/http.
type httpClient struct {
	baseURL         string
	httpClient      *http.Client
	token           string
	lastError       error
	lastRequest     *http.Request
	lastRequestBody []byte
	lastResponse    *http.Response
	koiError        *KoiError
	rawError        string
}

// NewHTTPClient creates a new HTTP client for the Koillection API.
func NewHTTPClient(baseURL string, timeout time.Duration) Client {
	jar, err := cookiejar.New(nil)
	if err != nil {
		fmt.Println("Error creating cookie jar:", err)
		return nil
	}
	return &httpClient{
		baseURL: strings.TrimSuffix(baseURL, "/"),
		httpClient: &http.Client{
			Jar:     jar,
			Timeout: timeout,
		},
		lastRequest:     nil,
		lastRequestBody: nil,
		lastResponse:    nil,
		koiError:        nil,
		rawError:        "",
	}
}

// GetResponse retrieves the response from the httpClient struct.
func (c *httpClient) GetResponse(ctx context.Context) string {
	if c.koiError != nil {
		// Return the structured error if available.
		errBytes, err := json.MarshalIndent(c.koiError, "", "  ")
		if err != nil {
			return fmt.Sprintf("Error marshaling KoiError: %v\nRaw Error: %s", err, c.rawError)
		}
		return fmt.Sprintf("Response Status: %s\nBody: %s", c.lastResponse.Status, string(errBytes))
	}
	if c.rawError != "" {
		// Return the raw error text.
		return fmt.Sprintf("Response Status: %s\nBody: %s", c.lastResponse.Status, c.rawError)
	}
	if c.lastResponse == nil {
		return "No response"
	}
	body, err := io.ReadAll(c.lastResponse.Body)
	// Reset the response body so it can be read again if needed.
	c.lastResponse.Body = io.NopCloser(bytes.NewReader(body))
	if err != nil {
		return fmt.Sprintf("Error reading response body: %v\nRaw Error: %s", err, c.rawError)
	}
	return fmt.Sprintf("Response Status: %s\nBody: %s", c.lastResponse.Status, string(body))
}

// doRequest sends an HTTP request, stores it and the response in the httpClient struct, and returns the response.
func (c *httpClient) doRequest(ctx context.Context, method, path string, body io.Reader, multipartContentType string) (*http.Response, error) {
	var bodyBytes []byte
	if body != nil {
		var err error
		bodyBytes, err = io.ReadAll(body)
		if err != nil {
			c.lastRequest = nil
			c.lastRequestBody = nil
			c.lastResponse = nil
			c.koiError = nil
			c.rawError = fmt.Sprintf("Error reading request body: %v", err)
			c.lastError = err
			return nil, fmt.Errorf("reading request body: %w", err)
		}
	}

	// Reset the body for the request.
	var reqBody io.Reader
	if bodyBytes != nil {
		reqBody = bytes.NewReader(bodyBytes)
	}

	req, err := http.NewRequestWithContext(ctx, method, c.baseURL+path, reqBody)
	if err != nil {
		c.lastRequest = nil
		c.lastRequestBody = nil
		c.lastResponse = nil
		c.koiError = nil
		c.rawError = fmt.Sprintf("Error creating request: %v", err)
		c.lastError = err
		return nil, fmt.Errorf("creating request: %w", err)
	}

	if multipartContentType != "" {
		req.Header.Set("Content-Type", multipartContentType)
	} else if body != nil {
		req.Header.Set("Content-Type", "application/ld+json")
	}
	if path == "/api/metrics" {
		req.Header.Set("Accept", "text/plain")
	} else {
		req.Header.Set("Accept", "application/ld+json")
	}

	resp, err := c.httpClient.Do(req)
	c.lastError = err
	c.lastRequest = req
	c.lastRequestBody = bodyBytes
	c.lastResponse = resp
	c.koiError = nil
	c.rawError = ""

	if err != nil {
		c.rawError = fmt.Sprintf("Request failed: %v", err)
		return nil, fmt.Errorf("sending request: %w", err)
	}

	// Read the response body for all status codes.
	respBodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		c.rawError = fmt.Sprintf("Error reading response body: %v", err)
	} else {
		c.rawError = string(respBodyBytes)
	}
	// Reset the response body so callers can read it.
	resp.Body = io.NopCloser(bytes.NewReader(respBodyBytes))

	// Handle 400 and 422 errors by attempting to unmarshal into KoiError.
	if resp.StatusCode == http.StatusBadRequest || resp.StatusCode == http.StatusUnprocessableEntity {
		if err == nil {
			var koiErr KoiError
			if err := json.Unmarshal(respBodyBytes, &koiErr); err != nil {
				c.koiError = nil // Explicitly set to nil if unmarshaling fails.
			} else {
				c.koiError = &koiErr
			}
		}
	}

	switch resp.StatusCode {
	case http.StatusOK, http.StatusCreated, http.StatusNoContent:
		return resp, nil
	case http.StatusBadRequest:
		return resp, ErrInvalidInput
	case http.StatusUnauthorized:
		return resp, ErrUnauthorized
	case http.StatusNotFound:
		return resp, ErrNotFound
	case http.StatusUnprocessableEntity:
		return resp, ErrUnprocessable
	default:
		return resp, fmt.Errorf("unexpected status code %d", resp.StatusCode)
	}
}

// getResource retrieves a single resource and decodes it into the provided struct.
func (c *httpClient) getResource(ctx context.Context, path string, out interface{}) error {
	resp, err := c.doRequest(ctx, http.MethodGet, path, nil, "")
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	return json.NewDecoder(resp.Body).Decode(out)
}

// listResources retrieves a paginated list of resources and decodes the member array.
func (c *httpClient) listResources(ctx context.Context, path string, page int, out interface{}) error {
	u, err := url.Parse(c.baseURL + path)
	if err != nil {
		return fmt.Errorf("parsing URL: %w", err)
	}
	q := u.Query()
	if page > 0 {
		q.Set("page", strconv.Itoa(page))
	}
	u.RawQuery = q.Encode()

	resp, err := c.doRequest(ctx, http.MethodGet, u.Path+"?"+u.RawQuery, nil, "")
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	// Handle JSON-LD response with "member" array.
	headerContent := resp.Header.Get("Content-Type")
	if strings.Contains(headerContent, "application/ld+json") {
		var wrapper struct {
			Member json.RawMessage `json:"member"`
		}
		if err := json.NewDecoder(resp.Body).Decode(&wrapper); err != nil {
			return fmt.Errorf("decoding response: %w", err)
		}
		return json.Unmarshal(wrapper.Member, out)
	}
	bodyBytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return err
	}
	return json.Unmarshal(bodyBytes, out)
}

// listResources retrieves all resources by looping through all pages and decodes the member array.
func (c *httpClient) listResources(ctx context.Context, path string, out interface{}, queryParams ...string) error {
	// Ensure out is a slice to collect all resources
	outValue := reflect.ValueOf(out)
	if outValue.Kind() != reflect.Ptr || outValue.Elem().Kind() != reflect.Slice {
		return fmt.Errorf("out must be a pointer to a slice")
	}
	sliceType := outValue.Elem().Type()
	slice := reflect.New(sliceType).Elem()

	u, err := url.Parse(c.baseURL + path)
	if err != nil {
		return fmt.Errorf("parsing URL: %w", err)
	}

	// Append query parameters
	q := u.Query()
	for _, param := range queryParams {
		if param != "" {
			parts := strings.SplitN(param, "=", 2)
			if len(parts) == 2 {
				q.Set(parts[0], parts[1])
			}
		}
	}

	page := 1
	for {
		// Add page to query
		q.Set("page", strconv.Itoa(page))
		u.RawQuery = q.Encode()

		resp, err := c.doRequest(ctx, http.MethodGet, u.Path+"?"+u.RawQuery, nil, "")
		if err != nil {
			return err
		}
		defer resp.Body.Close()

		// Handle JSON-LD response with "member" array
		headerContent := resp.Header.Get("Content-Type")
		if strings.Contains(headerContent, "application/ld+json") {
			var wrapper struct {
				Member json.RawMessage `json:"member"`
			}
			if err := json.NewDecoder(resp.Body).Decode(&wrapper); err != nil {
				return fmt.Errorf("decoding response: %w", err)
			}
			// Check if member array is empty to break the loop
			if len(wrapper.Member) == 0 || string(wrapper.Member) == "[]" {
				break
			}
			// Decode the member array into a temporary slice
			tempSlice := reflect.New(sliceType).Interface()
			if err := json.Unmarshal(wrapper.Member, tempSlice); err != nil {
				return fmt.Errorf("unmarshaling member array: %w", err)
			}
			// Append temporary slice to the main slice
			tempValue := reflect.ValueOf(tempSlice).Elem()
			for i := 0; i < tempValue.Len(); i++ {
				slice = reflect.Append(slice, tempValue.Index(i))
			}
		} else {
			bodyBytes, err := io.ReadAll(resp.Body)
			if err != nil {
				return err
			}
			// Check if body is empty to break the loop
			if len(bodyBytes) == 0 || string(bodyBytes) == "[]" {
				break
			}
			// Decode the response into a temporary slice
			tempSlice := reflect.New(sliceType).Interface()
			if err := json.Unmarshal(bodyBytes, tempSlice); err != nil {
				return fmt.Errorf("unmarshaling response: %w", err)
			}
			// Append temporary slice to the main slice
			tempValue := reflect.ValueOf(tempSlice).Elem()
			for i := 0; i < tempValue.Len(); i++ {
				slice = reflect.Append(slice, tempValue.Index(i))
			}
		}

		page++
	}

	// Set the output slice
	outValue.Elem().Set(slice)
	return nil
}

// postResource creates a resource and decodes the response into the provided struct.
func (c *httpClient) postResource(ctx context.Context, path string, in, out interface{}) error {
	body, err := json.Marshal(in)
	if err != nil {
		return fmt.Errorf("encoding request body: %w", err)
	}

	resp, err := c.doRequest(ctx, http.MethodPost, path, bytes.NewReader(body), "")
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if out != nil {
		return json.NewDecoder(resp.Body).Decode(out)
	}
	return nil
}

// putResource updates a resource and decodes the response into the provided struct.
func (c *httpClient) putResource(ctx context.Context, path string, in, out interface{}) error {
	body, err := json.Marshal(in)
	if err != nil {
		return fmt.Errorf("encoding request body: %w", err)
	}

	resp, err := c.doRequest(ctx, http.MethodPut, path, bytes.NewReader(body), "")
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	return json.NewDecoder(resp.Body).Decode(out)
}

// patchResource partially updates a resource and decodes the response into the provided struct.
func (c *httpClient) patchResource(ctx context.Context, path string, in, out interface{}) error {
	body, err := json.Marshal(in)
	if err != nil {
		return fmt.Errorf("encoding request body: %w", err)
	}

	resp, err := c.doRequest(ctx, http.MethodPatch, path, bytes.NewReader(body), "")
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	return json.NewDecoder(resp.Body).Decode(out)
}

// deleteResource deletes a resource.
func (c *httpClient) deleteResource(ctx context.Context, path string) error {
	resp, err := c.doRequest(ctx, http.MethodDelete, path, nil, "")
	if err != nil {
		return err
	}
	defer resp.Body.Close()
	return nil
}

// uploadFile uploads a file using multipart/form-data and decodes the response.
func (c *httpClient) uploadFile(ctx context.Context, path string, file []byte, fieldName string, out interface{}) error {
	body := &bytes.Buffer{}
	writer := multipart.NewWriter(body)
	part, err := writer.CreateFormFile(fieldName, "upload")
	if err != nil {
		return fmt.Errorf("creating form file: %w", err)
	}
	if _, err = part.Write(file); err != nil {
		return fmt.Errorf("writing file: %w", err)
	}
	if err := writer.Close(); err != nil {
		return fmt.Errorf("closing writer: %w", err)
	}

	contentType := writer.FormDataContentType()
	resp, err := c.doRequest(ctx, http.MethodPost, path, body, contentType)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	return json.NewDecoder(resp.Body).Decode(out)
}

// CheckLogin authenticates a user and returns a JWT token.
func (c *httpClient) CheckLogin(ctx context.Context, username, password string) (string, error) {
	reqBody := map[string]string{
		"username": username,
		"password": password,
	}
	body, err := json.Marshal(reqBody)
	if err != nil {
		return "", fmt.Errorf("encoding request body: %w", err)
	}

	resp, err := c.doRequest(ctx, http.MethodPost, "/api/authentication_token", bytes.NewReader(body), "")
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	var result struct {
		Token string `json:"token"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return "", fmt.Errorf("decoding response: %w", err)
	}

	c.token = result.Token
	return result.Token, nil
}
package koiApi

import (
	"context"
	"fmt"
	"os"
	"time"
)

// CollectionInterface defines methods for interacting with Collection resources.
type CollectionInterface interface {
	Create(ctx context.Context, client Client) (*Collection, error)                                                 // HTTP POST /api/collections
	Delete(ctx context.Context, client Client, collectionID ...ID) error                                            // HTTP DELETE /api/collections/{id}
	Get(ctx context.Context, client Client, collectionID ...ID) (*Collection, error)                                // HTTP GET /api/collections/{id}
	GetDefaultTemplate(ctx context.Context, client Client, collectionID ...ID) (*Template, error)                   // HTTP GET /api/collections/{id}/items_default_template
	GetParent(ctx context.Context, client Client, collectionID ...ID) (*Collection, error)                          // HTTP GET /api/collections/{id}/parent
	IRI() string                                                                                                    // /api/collections/{id}
	List(ctx context.Context, client Client) ([]*Collection, error)                                                 // HTTP GET /api/collections
	ListChildren(ctx context.Context, client Client, collectionID ...ID) ([]*Collection, error)                     // HTTP GET /api/collections/{id}/children
	ListCollectionData(ctx context.Context, client Client, collectionID ...ID) ([]*Datum, error)                    // HTTP GET /api/collections/{id}/data
	ListCollectionItems(ctx context.Context, client Client, collectionID ...ID) ([]*Item, error)                    // HTTP GET /api/collections/{id}/items
	Patch(ctx context.Context, client Client, collectionID ...ID) (*Collection, error)                              // HTTP PATCH /api/collections/{id}
	Update(ctx context.Context, client Client, collectionID ...ID) (*Collection, error)                             // HTTP PUT /api/collections/{id}
	UploadImage(ctx context.Context, client Client, file []byte, collectionID ...ID) (*Collection, error)           // HTTP POST /api/collections/{id}/image
	UploadImageByFile(ctx context.Context, client Client, filename string, collectionID ...ID) (*Collection, error) // HTTP POST /api/collections/{id}/image
}

// Collection represents a collection in Koillection, combining fields for JSON-LD and API interactions.
type Collection struct {
	Context              *Context   `json:"@context,omitempty" access:"rw"`             // JSON-LD only
	_ID                  ID         `json:"@id,omitempty" access:"ro"`                  // JSON-LD only
	Type                 string     `json:"@type,omitempty" access:"rw"`                // JSON-LD only
	ID                   ID         `json:"id,omitempty" access:"ro"`                   // Identifier
	Title                string     `json:"title" access:"rw"`                          // Collection title
	Parent               *string    `json:"parent,omitempty" access:"rw"`               // Parent collection IRI
	Owner                *string    `json:"owner,omitempty" access:"ro"`                // Owner IRI
	Color                string     `json:"color,omitempty" access:"ro"`                // Color code
	Image                *string    `json:"image,omitempty" access:"ro"`                // Image URL
	SeenCounter          int        `json:"seenCounter,omitempty" access:"ro"`          // View count
	ItemsDefaultTemplate *string    `json:"itemsDefaultTemplate,omitempty" access:"rw"` // Default template IRI
	Visibility           Visibility `json:"visibility,omitempty" access:"rw"`           // Visibility level
	ParentVisibility     *string    `json:"parentVisibility,omitempty" access:"ro"`     // Parent visibility
	FinalVisibility      Visibility `json:"finalVisibility,omitempty" access:"ro"`      // Effective visibility
	ScrapedFromURL       *string    `json:"scrapedFromUrl,omitempty" access:"ro"`       // Source URL
	CreatedAt            time.Time  `json:"createdAt" access:"ro"`                      // Creation timestamp
	UpdatedAt            *time.Time `json:"updatedAt,omitempty" access:"ro"`            // Update timestamp
	File                 *string    `json:"file,omitempty" access:"wo"`                 // Image file data
	DeleteImage          *bool      `json:"deleteImage,omitempty" access:"wo"`          // Flag to delete image
}

// whichID
func (c *Collection) whichID(collectionID ...ID) ID {
	if len(collectionID) > 0 {
		return collectionID[0]
	}
	return c.ID
}

// Create
func (c *Collection) Create(ctx context.Context, client Client) (*Collection, error) {
	return client.CreateCollection(ctx, c)
}

// Delete
func (c *Collection) Delete(ctx context.Context, client Client, collectionID ...ID) error {
	id := c.whichID(collectionID...)
	return client.DeleteCollection(ctx, id)
}

// Get
func (c *Collection) Get(ctx context.Context, client Client, collectionID ...ID) (*Collection, error) {
	id := c.whichID(collectionID...)
	return client.GetCollection(ctx, id)
}

// GetDefaultTemplate
func (c *Collection) GetDefaultTemplate(ctx context.Context, client Client, collectionID ...ID) (*Template, error) {
	id := c.whichID(collectionID...)
	return client.GetCollectionDefaultTemplate(ctx, id)
}

// GetParent
func (c *Collection) GetParent(ctx context.Context, client Client, collectionID ...ID) (*Collection, error) {
	id := c.whichID(collectionID...)
	return client.GetCollectionParent(ctx, id)
}

// IRI
func (c *Collection) IRI() string {
	return fmt.Sprintf("/api/collections/%s", c.ID)
}

// List
func (c *Collection) List(ctx context.Context, client Client) ([]*Collection, error) {
	var allCollections []*Collection
	for page := 1; ; page++ {
		collections, err := client.ListCollections(ctx, page)
		if err != nil {
			return nil, fmt.Errorf("failed to list collections on page %d: %w", page, err)
		}
		if len(collections) == 0 {
			break
		}
		allCollections = append(allCollections, collections...)
	}
	return allCollections, nil
}

// ListChildren
func (c *Collection) ListChildren(ctx context.Context, client Client, collectionID ...ID) ([]*Collection, error) {
	id := c.whichID(collectionID...)
	var allChildren []*Collection
	for page := 1; ; page++ {
		children, err := client.ListCollectionChildren(ctx, id, page)
		if err != nil {
			return nil, fmt.Errorf("failed to list child collections for ID %s on page %d: %w", id, page, err)
		}
		if len(children) == 0 {
			break
		}
		allChildren = append(allChildren, children...)
	}
	return allChildren, nil
}

// ListCollectionData
func (c *Collection) ListCollectionData(ctx context.Context, client Client, collectionID ...ID) ([]*Datum, error) {
	id := c.whichID(collectionID...)
	var allData []*Datum
	for page := 1; ; page++ {
		data, err := client.ListCollectionData(ctx, id, page)
		if err != nil {
			return nil, fmt.Errorf("failed to list data for ID %s on page %d: %w", id, page, err)
		}
		if len(data) == 0 {
			break
		}
		allData = append(allData, data...)
	}
	return allData, nil
}

// ListCollectionItems
func (c *Collection) ListCollectionItems(ctx context.Context, client Client, collectionID ...ID) ([]*Item, error) {
	id := c.whichID(collectionID...)
	var allItems []*Item
	for page := 1; ; page++ {
		items, err := client.ListCollectionItems(ctx, id, page)
		if err != nil {
			return nil, fmt.Errorf("failed to list items for ID %s on page %d: %w", id, page, err)
		}
		if len(items) == 0 {
			break
		}
		allItems = append(allItems, items...)
	}
	return allItems, nil
}

// Patch
func (c *Collection) Patch(ctx context.Context, client Client, collectionID ...ID) (*Collection, error) {
	id := c.whichID(collectionID...)
	return client.PatchCollection(ctx, id, c)
}

// Update
func (c *Collection) Update(ctx context.Context, client Client, collectionID ...ID) (*Collection, error) {
	id := c.whichID(collectionID...)
	return client.UpdateCollection(ctx, id, c)
}

// UploadImage
func (c *Collection) UploadImage(ctx context.Context, client Client, file []byte, collectionID ...ID) (*Collection, error) {
	id := c.whichID(collectionID...)
	return client.UploadCollectionImage(ctx, id, file)
}

// UploadImageByFile
func (c *Collection) UploadImageByFile(ctx context.Context, client Client, filename string, collectionID ...ID) (*Collection, error) {
	id := c.whichID(collectionID...)
	file, err := os.ReadFile(filename)
	if err != nil {
		return nil, fmt.Errorf("failed to read file %s: %w", filename, err)
	}
	return c.UploadImage(ctx, client, file, id)
}
package koiApi

// Context represents the JSON-LD @context field.
type Context string // JSON-LD only
package koiApi

// DateFormat represents the date format preference for a user.
type DateFormat string

const (
	DateFormatDMYSlash DateFormat = "d/m/Y"
	DateFormatMDYSlash DateFormat = "m/d/Y"
	DateFormatYMDSlash DateFormat = "Y/m/d"
	DateFormatDMYDash  DateFormat = "d-m-Y"
	DateFormatMDYDash  DateFormat = "m-d-Y"
	DateFormatYMDDash  DateFormat = "Y-m-d" // Default
)

func (df DateFormat) String() string {
	return string(df)
}
package koiApi

import (
	"context"
	"fmt"
	"os"
	"time"
)

type DatumType string

const (
	DatumTypeText       DatumType = "text"
	DatumTypeTextarea   DatumType = "textarea"
	DatumTypeCountry    DatumType = "country"
	DatumTypeDate       DatumType = "date"
	DatumTypeRating     DatumType = "rating"
	DatumTypeNumber     DatumType = "number"
	DatumTypePrice      DatumType = "price"
	DatumTypeLink       DatumType = "link"
	DatumTypeList       DatumType = "list"
	DatumTypeChoiceList DatumType = "choice-list"
	DatumTypeCheckbox   DatumType = "checkbox"
	DatumTypeImage      DatumType = "image"
	DatumTypeFile       DatumType = "file"
	DatumTypeSign       DatumType = "sign"
	DatumTypeVideo      DatumType = "video"
	DatumTypeBlankLine  DatumType = "blank-line"
	DatumTypeSection    DatumType = "section"
)

func (dt DatumType) String() string {
	return string(dt)
}

// DatumInterface defines methods for interacting with Datum resources.
type DatumInterface interface {
	Create(ctx context.Context, client Client) (*Datum, error)                                            // HTTP POST /api/data
	Delete(ctx context.Context, client Client, datumID ...ID) error                                       // HTTP DELETE /api/data/{id}
	Get(ctx context.Context, client Client, datumID ...ID) (*Datum, error)                                // HTTP GET /api/data/{id}
	GetCollection(ctx context.Context, client Client, datumID ...ID) (*Collection, error)                 // HTTP GET /api/data/{id}/collection
	GetItem(ctx context.Context, client Client, datumID ...ID) (*Item, error)                             // HTTP GET /api/data/{id}/item
	IRI() string                                                                                          // /api/data/{id}
	List(ctx context.Context, client Client) ([]*Datum, error)                                            // HTTP GET /api/data
	Patch(ctx context.Context, client Client, datumID ...ID) (*Datum, error)                              // HTTP PATCH /api/data/{id}
	Update(ctx context.Context, client Client, datumID ...ID) (*Datum, error)                             // HTTP PUT /api/data/{id}
	UploadFile(ctx context.Context, client Client, file []byte, datumID ...ID) (*Datum, error)            // HTTP POST /api/data/{id}/file
	UploadFileByFile(ctx context.Context, client Client, filename string, datumID ...ID) (*Datum, error)  // HTTP POST /api/data/{id}/file
	UploadImage(ctx context.Context, client Client, image []byte, datumID ...ID) (*Datum, error)          // HTTP POST /api/data/{id}/image
	UploadImageByFile(ctx context.Context, client Client, filename string, datumID ...ID) (*Datum, error) // HTTP POST /api/data/{id}/image
	UploadVideo(ctx context.Context, client Client, video []byte, datumID ...ID) (*Datum, error)          // HTTP POST /api/data/{id}/video
	UploadVideoByFile(ctx context.Context, client Client, filename string, datumID ...ID) (*Datum, error) // HTTP POST /api/data/{id}/video
}

// Datum represents a custom data field in Koillection, combining fields for JSON-LD and API interactions.
type Datum struct {
	Context             *Context   `json:"@context,omitempty" access:"rw"`            // JSON-LD only
	_ID                 ID         `json:"@id,omitempty" access:"ro"`                 // JSON-LD only
	Type                string     `json:"@type,omitempty" access:"rw"`               // JSON-LD only
	ID                  ID         `json:"id,omitempty" access:"ro"`                  // Identifier
	Item                *string    `json:"item,omitempty" access:"rw"`                // Item IRI
	Collection          *string    `json:"collection,omitempty" access:"rw"`          // Collection IRI
	DatumType           DatumType  `json:"type" access:"rw"`                          // Custom data field type
	Label               string     `json:"label" access:"rw"`                         // Field label
	Value               *string    `json:"value,omitempty" access:"rw"`               // Field value
	Position            *int       `json:"position,omitempty" access:"rw"`            // Field position
	Currency            *string    `json:"currency,omitempty" access:"rw"`            // Currency code
	Image               *string    `json:"image,omitempty" access:"ro"`               // Image URL
	ImageSmallThumbnail *string    `json:"imageSmallThumbnail,omitempty" access:"ro"` // Small thumbnail URL
	ImageLargeThumbnail *string    `json:"imageLargeThumbnail,omitempty" access:"ro"` // Large thumbnail URL
	File                *string    `json:"file,omitempty" access:"ro"`                // File URL
	Video               *string    `json:"video,omitempty" access:"ro"`               // Video URL
	OriginalFilename    *string    `json:"originalFilename,omitempty" access:"ro"`    // Original file name
	ChoiceList          *string    `json:"choiceList,omitempty" access:"rw"`          // Choice list IRI
	Owner               *string    `json:"owner,omitempty" access:"ro"`               // Owner IRI
	Visibility          Visibility `json:"visibility,omitempty" access:"rw"`          // Visibility level
	ParentVisibility    *string    `json:"parentVisibility,omitempty" access:"ro"`    // Parent visibility
	FinalVisibility     Visibility `json:"finalVisibility,omitempty" access:"ro"`     // Effective visibility
	CreatedAt           time.Time  `json:"createdAt" access:"ro"`                     // Creation timestamp
	UpdatedAt           *time.Time `json:"updatedAt,omitempty" access:"ro"`           // Update timestamp
	FileImage           *string    `json:"fileImage,omitempty" access:"wo"`           // Image file data
	FileFile            *string    `json:"fileFile,omitempty" access:"wo"`            // File data
	FileVideo           *string    `json:"fileVideo,omitempty" access:"wo"`           // Video file data
}

// whichID
func (d *Datum) whichID(datumID ...ID) ID {
	if len(datumID) > 0 {
		return datumID[0]
	}
	return d.ID
}

// Create
func (d *Datum) Create(ctx context.Context, client Client) (*Datum, error) {
	return client.CreateDatum(ctx, d)
}

// Delete
func (d *Datum) Delete(ctx context.Context, client Client, datumID ...ID) error {
	id := d.whichID(datumID...)
	return client.DeleteDatum(ctx, id)
}

// Get
func (d *Datum) Get(ctx context.Context, client Client, datumID ...ID) (*Datum, error) {
	id := d.whichID(datumID...)
	return client.GetDatum(ctx, id)
}

// GetCollection
func (d *Datum) GetCollection(ctx context.Context, client Client, datumID ...ID) (*Collection, error) {
	id := d.whichID(datumID...)
	return client.GetDatumCollection(ctx, id)
}

// GetItem
func (d *Datum) GetItem(ctx context.Context, client Client, datumID ...ID) (*Item, error) {
	id := d.whichID(datumID...)
	return client.GetDatumItem(ctx, id)
}

// IRI
func (d *Datum) IRI() string {
	return fmt.Sprintf("/api/data/%s", d.ID)
}

// List
func (d *Datum) List(ctx context.Context, client Client) ([]*Datum, error) {
	var allData []*Datum
	for page := 1; ; page++ {
		data, err := client.ListData(ctx, page)
		if err != nil {
			return nil, fmt.Errorf("failed to list data on page %d: %w", page, err)
		}
		if len(data) == 0 {
			break
		}
		allData = append(allData, data...)
	}
	return allData, nil
}

// Patch
func (d *Datum) Patch(ctx context.Context, client Client, datumID ...ID) (*Datum, error) {
	id := d.whichID(datumID...)
	return client.PatchDatum(ctx, id, d)
}

// Update
func (d *Datum) Update(ctx context.Context, client Client, datumID ...ID) (*Datum, error) {
	id := d.whichID(datumID...)
	return client.UpdateDatum(ctx, id, d)
}

// UploadFile
func (d *Datum) UploadFile(ctx context.Context, client Client, file []byte, datumID ...ID) (*Datum, error) {
	id := d.whichID(datumID...)
	return client.UploadDatumFile(ctx, id, file)
}

// UploadFileByFile
func (d *Datum) UploadFileByFile(ctx context.Context, client Client, filename string, datumID ...ID) (*Datum, error) {
	id := d.whichID(datumID...)
	file, err := os.ReadFile(filename)
	if err != nil {
		return nil, fmt.Errorf("failed to read file %s: %w", filename, err)
	}
	return client.UploadDatumFile(ctx, id, file)
}

// UploadImage
func (d *Datum) UploadImage(ctx context.Context, client Client, image []byte, datumID ...ID) (*Datum, error) {
	id := d.whichID(datumID...)
	return client.UploadDatumImage(ctx, id, image)
}

// UploadImageByFile
func (d *Datum) UploadImageByFile(ctx context.Context, client Client, filename string, datumID ...ID) (*Datum, error) {
	id := d.whichID(datumID...)
	file, err := os.ReadFile(filename)
	if err != nil {
		return nil, fmt.Errorf("failed to read file %s: %w", filename, err)
	}
	return client.UploadDatumImage(ctx, id, file)
}

// UploadVideo
func (d *Datum) UploadVideo(ctx context.Context, client Client, video []byte, datumID ...ID) (*Datum, error) {
	id := d.whichID(datumID...)
	return client.UploadDatumVideo(ctx, id, video)
}

// UploadVideoByFile
func (d *Datum) UploadVideoByFile(ctx context.Context, client Client, filename string, datumID ...ID) (*Datum, error) {
	id := d.whichID(datumID...)
	file, err := os.ReadFile(filename)
	if err != nil {
		return nil, fmt.Errorf("failed to read file %s: %w", filename, err)
	}
	return client.UploadDatumVideo(ctx, id, file)
}
package koiApi

import (
	"context"
	"fmt"
)

// DeleteAllData deletes all accessible data from the Koillection database.
// It returns an error if any deletions fail, but continues processing to maximize cleanup.
// The error contains a list of individual failures.
func (c *httpClient) DeleteAllData(ctx context.Context) error {
	var errs []error

	// Helper function to append errors
	addError := func(err error, resource, id string) {
		if err != nil {
			errs = append(errs, fmt.Errorf("failed to delete %s %s: %w", resource, id, err))
		}
	}

	// Delete resources in dependency order: children first, then parents

	// 1. Delete Photos (depend on Albums)
	photos, err := c.ListPhotos(ctx, 1)
	addError(err, "photos list", "")
	for _, photo := range photos {
		err := c.DeletePhoto(ctx, photo.ID)
		addError(err, "photo", string(photo.ID))
	}

	// 2. Delete Wishes (depend on Wishlists)
	wishes, err := c.ListWishes(ctx, 1)
	addError(err, "wishes list", "")
	for _, wish := range wishes {
		err := c.DeleteWish(ctx, wish.ID)
		addError(err, "wish", string(wish.ID))
	}

	// 3. Delete Items (depend on Collections, have Loans, Tags, Data)
	items, err := c.ListItems(ctx, 1)
	addError(err, "items list", "")
	for _, item := range items {
		// Delete associated Loans
		loans, err := c.ListItemLoans(ctx, item.ID, 1)
		addError(err, "loans list for item", string(item.ID))
		for _, loan := range loans {
			err := c.DeleteLoan(ctx, loan.ID)
			addError(err, "loan", string(loan.ID))
		}

		// Delete associated Data
		data, err := c.ListItemData(ctx, item.ID, 1)
		addError(err, "data list for item", string(item.ID))
		for _, datum := range data {
			err := c.DeleteDatum(ctx, datum.ID)
			addError(err, "datum", string(datum.ID))
		}

		// Note: Tags are not deleted here as they may be shared; item-tag relations are cleared by deleting the item
		err = c.DeleteItem(ctx, item.ID)
		addError(err, "item", string(item.ID))
	}

	// 4. Delete Albums (have children and photos)
	albums, err := c.ListAlbums(ctx, 1)
	addError(err, "albums list", "")
	for _, album := range albums {
		// Delete child albums recursively
		children, err := c.ListAlbumChildren(ctx, album.ID, 1)
		addError(err, "album children list", string(album.ID))
		for _, child := range children {
			err := c.DeleteAlbum(ctx, child.ID)
			addError(err, "child album", string(child.ID))
		}
		err = c.DeleteAlbum(ctx, album.ID)
		addError(err, "album", string(album.ID))
	}

	// 5. Delete Wishlists (have children and wishes)
	wishlists, err := c.ListWishlists(ctx, 1)
	addError(err, "wishlists list", "")
	for _, wishlist := range wishlists {
		// Delete child wishlists recursively
		children, err := c.ListWishlistChildren(ctx, wishlist.ID, 1)
		addError(err, "wishlist children list", string(wishlist.ID))
		for _, child := range children {
			err := c.DeleteWishlist(ctx, child.ID)
			addError(err, "child wishlist", string(child.ID))
		}
		err = c.DeleteWishlist(ctx, wishlist.ID)
		addError(err, "wishlist", string(wishlist.ID))
	}

	// 6. Delete Collections (have children, items, data)
	collections, err := c.ListCollections(ctx, 1)
	addError(err, "collections list", "")
	for _, collection := range collections {
		// Delete child collections recursively
		children, err := c.ListCollectionChildren(ctx, collection.ID, 1)
		addError(err, "collection children list", string(collection.ID))
		for _, child := range children {
			err := c.DeleteCollection(ctx, child.ID)
			addError(err, "child collection", string(child.ID))
		}
		// Delete associated Data
		data, err := c.ListCollectionData(ctx, collection.ID, 1)
		addError(err, "data list for collection", string(collection.ID))
		for _, datum := range data {
			err := c.DeleteDatum(ctx, datum.ID)
			addError(err, "datum", string(datum.ID))
		}
		err = c.DeleteCollection(ctx, collection.ID)
		addError(err, "collection", string(collection.ID))
	}

	// 7. Delete Templates (have Fields)
	templates, err := c.ListTemplates(ctx, 1)
	addError(err, "templates list", "")
	for _, template := range templates {
		// Delete associated Fields
		fields, err := c.ListTemplateFields(ctx, template.ID, 1)
		addError(err, "fields list for template", string(template.ID))
		for _, field := range fields {
			err := c.DeleteField(ctx, field.ID)
			addError(err, "field", string(field.ID))
		}
		err = c.DeleteTemplate(ctx, template.ID)
		addError(err, "template", string(template.ID))
	}

	// 8. Delete Tags (depend on Tag Categories)
	tags, err := c.ListTags(ctx, 1)
	addError(err, "tags list", "")
	for _, tag := range tags {
		err := c.DeleteTag(ctx, tag.ID)
		addError(err, "tag", string(tag.ID))
	}

	// 9. Delete Tag Categories
	tagCategories, err := c.ListTagCategories(ctx, 1)
	addError(err, "tag categories list", "")
	for _, category := range tagCategories {
		err := c.DeleteTagCategory(ctx, category.ID)
		addError(err, "tag category", string(category.ID))
	}

	// 10. Delete Choice Lists
	choiceLists, err := c.ListChoiceLists(ctx, 1)
	addError(err, "choice lists list", "")
	for _, choiceList := range choiceLists {
		err := c.DeleteChoiceList(ctx, choiceList.ID)
		addError(err, "choice list", string(choiceList.ID))
	}

	// 11. Delete Inventories
	inventories, err := c.ListInventories(ctx, 1)
	addError(err, "inventories list", "")
	for _, inventory := range inventories {
		err := c.DeleteInventory(ctx, inventory.ID)
		addError(err, "inventory", string(inventory.ID))
	}

	/* // 12. Delete Logs (if accessible)
	logs, err := c.ListLogs(ctx, 1)
	addError(err, "logs list", "")
	for _, log := range logs {
		err := c.DeleteLog(ctx, log.ID)
		addError(err, "log", string(log.ID))
	}
	*/
	// Note: Users are not deleted as the API only provides GET operations for users

	// Combine errors if any
	if len(errs) > 0 {
		return fmt.Errorf("encountered %d errors during deletion: %v", len(errs), errs)
	}

	return nil
}
package koiApi

import (
	"context"
	"fmt"
)

// FieldType represents the type of a template field (same values as DatumType).
type FieldType string // Read and write

const (
	FieldTypeText       FieldType = "text"
	FieldTypeTextarea   FieldType = "textarea"
	FieldTypeCountry    FieldType = "country"
	FieldTypeDate       FieldType = "date"
	FieldTypeRating     FieldType = "rating"
	FieldTypeNumber     FieldType = "number"
	FieldTypePrice      FieldType = "price"
	FieldTypeLink       FieldType = "link"
	FieldTypeList       FieldType = "list"
	FieldTypeChoiceList FieldType = "choice-list"
	FieldTypeCheckbox   FieldType = "checkbox"
	FieldTypeImage      FieldType = "image"
	FieldTypeFile       FieldType = "file"
	FieldTypeSign       FieldType = "sign"
	FieldTypeVideo      FieldType = "video"
	FieldTypeBlankLine  FieldType = "blank-line"
	FieldTypeSection    FieldType = "section"
)

func (ft FieldType) String() string {
	return string(ft)
}

// FieldInterface defines methods for interacting with Field resources.
type FieldInterface interface {
	Create(ctx context.Context, client Client) (*Field, error)                        // HTTP POST /api/fields
	Delete(ctx context.Context, client Client, fieldID ...ID) error                   // HTTP DELETE /api/fields/{id}
	Get(ctx context.Context, client Client, fieldID ...ID) (*Field, error)            // HTTP GET /api/fields/{id}
	GetTemplate(ctx context.Context, client Client, fieldID ...ID) (*Template, error) // HTTP GET /api/fields/{id}/template
	IRI() string                                                                      // /api/fields/{id}
	List(ctx context.Context, client Client) ([]*Field, error)                        // HTTP GET /api/fields
	Patch(ctx context.Context, client Client, fieldID ...ID) (*Field, error)          // HTTP PATCH /api/fields/{id}
	Update(ctx context.Context, client Client, fieldID ...ID) (*Field, error)         // HTTP PUT /api/fields/{id}
}

// Field represents a template field in Koillection, combining fields for JSON-LD and API interactions.
type Field struct {
	Context    *Context   `json:"@context,omitempty" access:"rw"`   // JSON-LD only
	_ID        ID         `json:"@id,omitempty" access:"ro"`        // JSON-LD only
	Type       string     `json:"@type,omitempty" access:"rw"`      // JSON-LD only
	ID         ID         `json:"id,omitempty" access:"ro"`         // Identifier
	Name       string     `json:"name" access:"rw"`                 // Field name
	Position   int        `json:"position" access:"rw"`             // Field position
	FieldType  FieldType  `json:"type" access:"rw"`                 // Field type
	ChoiceList *string    `json:"choiceList,omitempty" access:"rw"` // Choice list IRI
	Template   *string    `json:"template" access:"rw"`             // Template IRI
	Visibility Visibility `json:"visibility,omitempty" access:"rw"` // Visibility level
	Owner      *string    `json:"owner,omitempty" access:"ro"`      // Owner IRI
}

// whichID
func (f *Field) whichID(fieldID ...ID) ID {
	if len(fieldID) > 0 {
		return fieldID[0]
	}
	return f.ID
}

// Create
func (f *Field) Create(ctx context.Context, client Client) (*Field, error) {
	return client.CreateField(ctx, f)
}

// Delete
func (f *Field) Delete(ctx context.Context, client Client, fieldID ...ID) error {
	id := f.whichID(fieldID...)
	return client.DeleteField(ctx, id)
}

// Get
func (f *Field) Get(ctx context.Context, client Client, fieldID ...ID) (*Field, error) {
	id := f.whichID(fieldID...)
	return client.GetField(ctx, id)
}

// GetTemplate
func (f *Field) GetTemplate(ctx context.Context, client Client, fieldID ...ID) (*Template, error) {
	id := f.whichID(fieldID...)
	return client.GetFieldTemplate(ctx, id)
}

// IRI
func (f *Field) IRI() string {
	return fmt.Sprintf("/api/fields/%s", f.ID)
}

// List
func (f *Field) List(ctx context.Context, client Client) ([]*Field, error) {
	var allFields []*Field
	for page := 1; ; page++ {
		fields, err := client.ListFields(ctx, page)
		if err != nil {
			return nil, fmt.Errorf("failed to list fields on page %d: %w", page, err)
		}
		if len(fields) == 0 {
			break
		}
		allFields = append(allFields, fields...)
	}
	return allFields, nil
}

// Patch
func (f *Field) Patch(ctx context.Context, client Client, fieldID ...ID) (*Field, error) {
	id := f.whichID(fieldID...)
	return client.PatchField(ctx, id, f)
}

// Update
func (f *Field) Update(ctx context.Context, client Client, fieldID ...ID) (*Field, error) {
	id := f.whichID(fieldID...)
	return client.UpdateField(ctx, id, f)
}
package koiApi

type ID string
package koiApi

import (
	"context"
	"fmt"
	"time"
)

// InventoryInterface defines methods for interacting with Inventory resources.
type InventoryInterface interface {
	Delete(ctx context.Context, client Client, inventoryID ...ID) error            // HTTP DELETE /api/inventories/{id}
	Get(ctx context.Context, client Client, inventoryID ...ID) (*Inventory, error) // HTTP GET /api/inventories/{id}
	IRI() string                                                                   // /api/inventories/{id}
	List(ctx context.Context, client Client) ([]*Inventory, error)                 // HTTP GET /api/inventories
}

// Inventory represents an inventory record in Koillection, combining fields for JSON-LD and API interactions.
type Inventory struct {
	Context   *Context   `json:"@context,omitempty" access:"rw"`  // JSON-LD only
	_ID       ID         `json:"@id,omitempty" access:"ro"`       // JSON-LD only
	Type      string     `json:"@type,omitempty" access:"rw"`     // JSON-LD only
	ID        ID         `json:"id,omitempty" access:"ro"`        // Identifier
	Name      string     `json:"name" access:"rw"`                // Inventory name
	Content   []string   `json:"content" access:"rw"`             // Inventory content
	Owner     *string    `json:"owner,omitempty" access:"ro"`     // Owner IRI
	CreatedAt time.Time  `json:"createdAt" access:"ro"`           // Creation timestamp
	UpdatedAt *time.Time `json:"updatedAt,omitempty" access:"ro"` // Update timestamp
}

// whichID
func (i *Inventory) whichID(inventoryID ...ID) ID {
	if len(inventoryID) > 0 {
		return inventoryID[0]
	}
	return i.ID
}

// Delete
func (i *Inventory) Delete(ctx context.Context, client Client, inventoryID ...ID) error {
	id := i.whichID(inventoryID...)
	return client.DeleteInventory(ctx, id)
}

// Get
func (i *Inventory) Get(ctx context.Context, client Client, inventoryID ...ID) (*Inventory, error) {
	id := i.whichID(inventoryID...)
	return client.GetInventory(ctx, id)
}

// IRI
func (i *Inventory) IRI() string {
	return fmt.Sprintf("/api/inventories/%s", i.ID)
}

// List
func (i *Inventory) List(ctx context.Context, client Client) ([]*Inventory, error) {
	var allInventories []*Inventory
	for page := 1; ; page++ {
		inventories, err := client.ListInventories(ctx, page)
		if err != nil {
			return nil, fmt.Errorf("failed to list inventories on page %d: %w", page, err)
		}
		if len(inventories) == 0 {
			break
		}
		allInventories = append(allInventories, inventories...)
	}
	return allInventories, nil
}
package koiApi

import (
	"context"
	"fmt"
	"os"
	"time"
)

// ItemInterface defines methods for interacting with Item resources.
type ItemInterface interface {
	Create(ctx context.Context, client Client) (*Item, error)                                           // HTTP POST /api/items
	Delete(ctx context.Context, client Client, itemID ...ID) error                                      // HTTP DELETE /api/items/{id}
	Get(ctx context.Context, client Client, itemID ...ID) (*Item, error)                                // HTTP GET /api/items/{id}
	GetCollection(ctx context.Context, client Client, itemID ...ID) (*Collection, error)                // HTTP GET /api/items/{id}/collection
	IRI() string                                                                                        // /api/items/{id}
	List(ctx context.Context, client Client) ([]*Item, error)                                           // HTTP GET /api/items
	ListData(ctx context.Context, client Client, itemID ...ID) ([]*Datum, error)                        // HTTP GET /api/items/{id}/data
	ListLoans(ctx context.Context, client Client, itemID ...ID) ([]*Loan, error)                        // HTTP GET /api/items/{id}/loans
	ListRelatedItems(ctx context.Context, client Client, itemID ...ID) ([]*Item, error)                 // HTTP GET /api/items/{id}/related_items
	ListTags(ctx context.Context, client Client, itemID ...ID) ([]*Tag, error)                          // HTTP GET /api/items/{id}/tags
	Patch(ctx context.Context, client Client, itemID ...ID) (*Item, error)                              // HTTP PATCH /api/items/{id}
	Update(ctx context.Context, client Client, itemID ...ID) (*Item, error)                             // HTTP PUT /api/items/{id}
	UploadImage(ctx context.Context, client Client, file []byte, itemID ...ID) (*Item, error)           // HTTP POST /api/items/{id}/image
	UploadImageByFile(ctx context.Context, client Client, filename string, itemID ...ID) (*Item, error) // HTTP POST /api/items/{id}/image
}

// Item represents an item within a collection, combining fields for JSON-LD and API interactions.
type Item struct {
	Context             *Context   `json:"@context,omitempty" access:"rw"`            // JSON-LD only
	_ID                 ID         `json:"@id,omitempty" access:"ro"`                 // JSON-LD only
	Type                string     `json:"@type,omitempty" access:"rw"`               // JSON-LD only
	ID                  ID         `json:"id,omitempty" access:"ro"`                  // Identifier
	Name                string     `json:"name" access:"rw"`                          // Item name
	Quantity            int        `json:"quantity" access:"rw"`                      // Item quantity
	Collection          *string    `json:"collection" access:"rw"`                    // Collection IRI
	Owner               *string    `json:"owner,omitempty" access:"ro"`               // Owner IRI
	Image               *string    `json:"image,omitempty" access:"ro"`               // Image URL
	ImageSmallThumbnail *string    `json:"imageSmallThumbnail,omitempty" access:"ro"` // Small thumbnail URL
	ImageLargeThumbnail *string    `json:"imageLargeThumbnail,omitempty" access:"ro"` // Large thumbnail URL
	SeenCounter         int        `json:"seenCounter,omitempty" access:"ro"`         // View count
	Visibility          Visibility `json:"visibility,omitempty" access:"rw"`          // Visibility level
	ParentVisibility    *string    `json:"parentVisibility,omitempty" access:"ro"`    // Parent visibility
	FinalVisibility     Visibility `json:"finalVisibility,omitempty" access:"ro"`     // Effective visibility
	ScrapedFromURL      *string    `json:"scrapedFromUrl,omitempty" access:"ro"`      // Source URL
	CreatedAt           time.Time  `json:"createdAt" access:"ro"`                     // Creation timestamp
	UpdatedAt           *time.Time `json:"updatedAt,omitempty" access:"ro"`           // Update timestamp
	Tags                []string   `json:"tags,omitempty" access:"wo"`                // Tag IRIs
	RelatedItems        []string   `json:"relatedItems,omitempty" access:"wo"`        // Related item IRIs
	File                *string    `json:"file,omitempty" access:"wo"`                // Image file data
}

// whichID
func (i *Item) whichID(itemID ...ID) ID {
	if len(itemID) > 0 {
		return itemID[0]
	}
	return i.ID
}

// Create
func (i *Item) Create(ctx context.Context, client Client) (*Item, error) {
	return client.CreateItem(ctx, i)
}

// Delete
func (i *Item) Delete(ctx context.Context, client Client, itemID ...ID) error {
	id := i.whichID(itemID...)
	return client.DeleteItem(ctx, id)
}

// Get
func (i *Item) Get(ctx context.Context, client Client, itemID ...ID) (*Item, error) {
	id := i.whichID(itemID...)
	return client.GetItem(ctx, id)
}

// GetCollection
func (i *Item) GetCollection(ctx context.Context, client Client, itemID ...ID) (*Collection, error) {
	id := i.whichID(itemID...)
	return client.GetItemCollection(ctx, id)
}

// IRI
func (i *Item) IRI() string {
	return fmt.Sprintf("/api/items/%s", i.ID)
}

// List
func (i *Item) List(ctx context.Context, client Client) ([]*Item, error) {
	var allItems []*Item
	for page := 1; ; page++ {
		items, err := client.ListItems(ctx, page)
		if err != nil {
			return nil, fmt.Errorf("failed to list items on page %d: %w", page, err)
		}
		if len(items) == 0 {
			break
		}
		allItems = append(allItems, items...)
	}
	return allItems, nil
}

// ListData
func (i *Item) ListData(ctx context.Context, client Client, itemID ...ID) ([]*Datum, error) {
	id := i.whichID(itemID...)
	var allData []*Datum
	for page := 1; ; page++ {
		data, err := client.ListItemData(ctx, id, page)
		if err != nil {
			return nil, fmt.Errorf("failed to list data for ID %s on page %d: %w", id, page, err)
		}
		if len(data) == 0 {
			break
		}
		allData = append(allData, data...)
	}
	return allData, nil
}

// ListLoans
func (i *Item) ListLoans(ctx context.Context, client Client, itemID ...ID) ([]*Loan, error) {
	id := i.whichID(itemID...)
	var allLoans []*Loan
	for page := 1; ; page++ {
		loans, err := client.ListItemLoans(ctx, id, page)
		if err != nil {
			return nil, fmt.Errorf("failed to list loans for ID %s on page %d: %w", id, page, err)
		}
		if len(loans) == 0 {
			break
		}
		allLoans = append(allLoans, loans...)
	}
	return allLoans, nil
}

// ListRelatedItems
func (i *Item) ListRelatedItems(ctx context.Context, client Client, itemID ...ID) ([]*Item, error) {
	id := i.whichID(itemID...)
	var allRelatedItems []*Item
	for page := 1; ; page++ {
		relatedItems, err := client.ListItemRelatedItems(ctx, id, page)
		if err != nil {
			return nil, fmt.Errorf("failed to list related items for ID %s on page %d: %w", id, page, err)
		}
		if len(relatedItems) == 0 {
			break
		}
		allRelatedItems = append(allRelatedItems, relatedItems...)
	}
	return allRelatedItems, nil
}

// ListTags
func (i *Item) ListTags(ctx context.Context, client Client, itemID ...ID) ([]*Tag, error) {
	id := i.whichID(itemID...)
	var allTags []*Tag
	for page := 1; ; page++ {
		tags, err := client.ListItemTags(ctx, id, page)
		if err != nil {
			return nil, fmt.Errorf("failed to list tags for ID %s on page %d: %w", id, page, err)
		}
		if len(tags) == 0 {
			break
		}
		allTags = append(allTags, tags...)
	}
	return allTags, nil
}

// Patch
func (i *Item) Patch(ctx context.Context, client Client, itemID ...ID) (*Item, error) {
	id := i.whichID(itemID...)
	return client.PatchItem(ctx, id, i)
}

// Update
func (i *Item) Update(ctx context.Context, client Client, itemID ...ID) (*Item, error) {
	id := i.whichID(itemID...)
	return client.UpdateItem(ctx, id, i)
}

// UploadImage
func (i *Item) UploadImage(ctx context.Context, client Client, file []byte, itemID ...ID) (*Item, error) {
	id := i.whichID(itemID...)
	return client.UploadItemImage(ctx, id, file)
}

// UploadImageByFile
func (i *Item) UploadImageByFile(ctx context.Context, client Client, filename string, itemID ...ID) (*Item, error) {
	id := i.whichID(itemID...)
	file, err := os.ReadFile(filename)
	if err != nil {
		return nil, fmt.Errorf("failed to read file %s: %w", filename, err)
	}
	return client.UploadItemImage(ctx, id, file)
}
package koiApi

import (
	"context"
	"encoding/json"
	"fmt"
	"net/url"
	"os"
	"strconv"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
)

// Credentials holds the username and password from creds.yaml.
type Credentials struct {
	URL      string `json:"url"`
	Username string `json:"username"`
	Password string `json:"password"`
}

// loadCredentials reads username and password from creds.yaml.
func loadCredentials(t *testing.T) (Credentials, error) {
	data, err := os.ReadFile("creds.json")
	if err != nil {
		return Credentials{}, err
	}
	var creds Credentials
	if err := json.Unmarshal(data, &creds); err != nil {
		return Credentials{}, err
	}
	return creds, nil
}

func TestCollectionAndItemLifecycleWithRealServer(t *testing.T) {
	// Load credentials
	creds, err := loadCredentials(t)
	assert.NoError(t, err, "Failed to load creds.yaml")
	assert.NotEmpty(t, creds.URL, "Username is empty")
	assert.NotEmpty(t, creds.Username, "Username is empty")
	assert.NotEmpty(t, creds.Password, "Password is empty")

	// Initialize client (assumes a real client implementation)
	client := NewHTTPClient(creds.URL, 30*time.Second)

	ctx := context.Background()

	// Authenticate
	token, err := client.CheckLogin(ctx, creds.Username, creds.Password)
	assert.NoError(t, err, "Failed to authenticate")
	assert.NotEmpty(t, token, "Authentication token is empty")
	// Assume client is configured to use token for subsequent requests

	RemoveAllCollections(t, client, ctx)

	// Create collection
	var testName = "TEST" + time.Now().Format("15:04:05")
	collection := &Collection{
		Title:      testName,
		Visibility: VisibilityPublic,
	}
	resultCollection, err := client.CreateCollection(ctx, collection)
	assert.NoError(t, err, "Failed to create collection")
	assert.NotEmpty(t, resultCollection.ID, "Collection ID is empty")
	assert.Equal(t, testName, resultCollection.Title, "Collection title mismatch")

	// Create IRI from collection ID
	collectionIRI := resultCollection.IRI()
	assert.NotEmpty(t, collectionIRI, "Collection IRI is empty")
	assert.Equal(t, fmt.Sprintf("/api/collections/%s", resultCollection.ID), collectionIRI, "Collection IRI mismatch")
	resultCollection.UploadImageByFile(ctx, client, "./picture002.jpg")

	// Create item
	item := &Item{
		Name:       "Test Item",
		Quantity:   1,
		Collection: &collectionIRI,
		Visibility: VisibilityPublic,
	}
	resultItem, err := client.CreateItem(ctx, item)
	assert.NoError(t, err, "Failed to create item")
	assert.NotEmpty(t, resultItem.ID, "Item ID is empty")
	assert.Equal(t, "Test Item", resultItem.Name, "Item name mismatch")

	// Create one datum for each DatumType
	datumTypes := []DatumType{
		DatumTypeText, DatumTypeTextarea, DatumTypeCountry, DatumTypeDate,
		DatumTypeRating, DatumTypeNumber, DatumTypePrice, DatumTypeLink,
		DatumTypeList,
		DatumTypeChoiceList,
		DatumTypeCheckbox, DatumTypeImage,
		DatumTypeFile, DatumTypeSign, DatumTypeVideo,
		DatumTypeBlankLine, DatumTypeSection,
	}
	itemIRI := resultItem.IRI()
	resultItem, err = resultItem.UploadImageByFile(ctx, client, "./picture001.jpg")
	if err != nil {
		client.PrintError(ctx)
		t.Fatalf("Failed to upload image: %v\n", err)
	}
	resultItem, err = resultItem.UploadImageByFile(ctx, client, "./picture002.jpg")
	if err != nil {
		t.Fatalf("Failed to upload image: %v\n", err)
	}

	assert.NotEmpty(t, itemIRI, "Item IRI is empty")
	assert.Equal(t, fmt.Sprintf("/api/items/%s", resultItem.ID), itemIRI, "Item IRI mismatch")

	// Create a datum for the it
	name := "Name of the thing"

	datum := &Datum{
		Item:       &itemIRI,
		DatumType:  DatumTypeText,
		Label:      "Name",
		Value:      &name,
		Visibility: VisibilityPublic,
	}

	datum.Print("%s:\n", *datum.Item)
	fmt.Printf("\n")

	resultDatum, err := client.CreateDatum(ctx, datum)
	assert.NoError(t, err, "Failed to create datum")
	assert.NotEmpty(t, resultDatum.ID, "Datum ID is empty")
	assert.Equal(t, DatumTypeText, resultDatum.DatumType, "Datum type mismatch")
	assert.Equal(t, name, *resultDatum.Value, "Datum value mismatch")
	assert.Equal(t, VisibilityPublic, resultDatum.Visibility, "Datum visibility mismatch")
	assert.Equal(t, itemIRI, *resultDatum.Item, "Datum item mismatch")

	for _, dt := range datumTypes {
		value := "test-value"
		currency := ""
		if dt == DatumTypeCheckbox {
			value = "1"
		} else if dt == DatumTypeDate {
			value = "2023-01-01"
		} else if dt == DatumTypeNumber {
			value = "42"
		} else if dt == DatumTypeRating {
			value = "5"
		} else if dt == DatumTypePrice {
			value = "99.99"
			currency = "EUR"
		} else if dt == DatumTypeCountry {
			value = "US"
		} else if dt == DatumTypeLink {
			value = "https://example.com"
		} else if dt == DatumTypeChoiceList {
			continue
		} else if dt == DatumTypeList {
			value = `["List item 1", "List item 2"]`
		} else if dt == DatumTypeSign || dt == DatumTypeImage || dt == DatumTypeFile || dt == DatumTypeVideo {
			continue
		} else if dt == DatumTypeBlankLine {
			value = "This is a blank line"
		} else if dt == DatumTypeSection {
			value = "Section title"
		}
		var strP *string = &value
		if *strP == "" {
			strP = nil
		}
		datum = &Datum{
			Item:       &itemIRI,
			DatumType:  dt,
			Label:      string(dt) + " Field",
			Value:      strP,
			Visibility: VisibilityPublic,
			Currency:   &currency,
		}

		datum.Print("%s:\n", *datum.Item)
		fmt.Printf("\n")

		err = validateDatumValue(dt, value)
		if err != nil {
			t.Fatalf("Invalid datum value '%s' for type %s: %v", value, dt, err)
		}

		resultDatum, err := client.CreateDatum(ctx, datum)
		assert.NoError(t, err, "Failed to create datum for type %s", dt)
		assert.NotEmpty(t, resultDatum.ID, "Datum ID is empty for type %s", dt)
		//assert.Equal(t, dt, resultDatum.DatumType, "Datum type mismatch for %s", dt)
		//assert.Equal(t, value, *resultDatum.Value, "Datum value mismatch for %s", dt)

		// Upload file for image, file, or video types
		//if datum.Value != nil {
		if dt == DatumTypeImage {
			_, err = resultDatum.UploadImageByFile(ctx, client, "./picture002.jpg")
			assert.NoError(t, err, "Failed to upload image for datum %s", dt)
		} else if dt == DatumTypeFile {
			_, err = resultDatum.UploadFileByFile(ctx, client, "./picture002.jpg")
			assert.NoError(t, err, "Failed to upload file for datum %s", dt)
		} else if dt == DatumTypeVideo {
			_, err = resultDatum.UploadVideoByFile(ctx, client, "./picture002.jpg")
			assert.NoError(t, err, "Failed to upload video for datum %s", dt)
		}
		//}
	}

	// Fetch item
	fetchedItem, err := client.GetItem(ctx, resultItem.ID)
	assert.NoError(t, err, "Failed to fetch item")
	assert.Equal(t, resultItem.ID, fetchedItem.ID, "Fetched item ID mismatch")
	assert.Equal(t, resultItem.Name, fetchedItem.Name, "Fetched item name mismatch")

	// Delete item
	//err = client.DeleteItem(ctx, resultItem.ID)
	//assert.NoError(t, err, "Failed to delete item")

	// Delete collection
	//err = client.DeleteCollection(ctx, resultCollection.ID)
	//assert.NoError(t, err, "Failed to delete collection")
}

// validateDatumValue validates the value for a given DatumType.
func validateDatumValue(dt DatumType, value string) error {
	switch dt {
	case DatumTypeCountry:
		// Simplified list of ISO 3166-1 alpha-2 codes
		validCountries := map[string]bool{
			"US": true, "FR": true, "JP": true, "GB": true, "CA": true,
			// Add more codes as needed
		}
		if !validCountries[value] {
			return fmt.Errorf("invalid country code: %s, must be a 2-letter ISO 3166-1 alpha-2 code", value)
		}
	case DatumTypeRating:
		num, err := strconv.Atoi(value)
		if err != nil {
			return fmt.Errorf("rating must be an integer, got %s", value)
		}
		if num < 0 || num > 10 {
			return fmt.Errorf("rating must be between 0 and 10, got %d", num)
		}
	case DatumTypeCheckbox:
		if value != "0" && value != "1" {
			return fmt.Errorf("checkbox must be '0' or '1', got %s", value)
		}
	case DatumTypeLink:
		parsedURL, err := url.Parse(value)
		if err != nil || parsedURL.Scheme == "" || parsedURL.Host == "" {
			return fmt.Errorf("link must be a valid URL, got %s", value)
		}
	case DatumTypeChoiceList:
		var list []string
		if err := json.Unmarshal([]byte(value), &list); err != nil {
			return fmt.Errorf("choice-list must be a JSON string array, e.g., '[\"Value 1\", \"Value 2\"]', got %s", value)
		}
	case DatumTypeText, DatumTypeTextarea, DatumTypeList, DatumTypeSign, DatumTypeBlankLine, DatumTypeSection:
		if value == "" {
			return fmt.Errorf("%s value cannot be empty", dt)
		}
	case DatumTypeDate:
		if _, err := time.Parse("2006-01-02", value); err != nil {
			return fmt.Errorf("date must be in YYYY-MM-DD format, got %s", value)
		}
	case DatumTypeNumber:
		if _, err := strconv.Atoi(value); err != nil {
			return fmt.Errorf("number must be an integer, got %s", value)
		}
		/* 	case DatumTypePrice:
		if _, err := strconv.ParseFloat(value, 64); err != nil {
			return fmt.Errorf("price must be a number, got %s", value)
		}
		*/
	}
	return nil
}

func RemoveAllCollections(t *testing.T, client Client, ctx context.Context) {
	collections, err := client.ListCollections(ctx, 1)
	if err != nil {
		t.Fatalf("Failed to list collections: %v", err)
	}
	for _, collection := range collections {
		err = client.DeleteCollection(ctx, collection.ID)
		if err != nil {
			t.Fatalf("Failed to delete collection %s: %v", collection.ID, err)
		}
	}
}
package koiApi

import (
	"context"
	"fmt"
	"time"
)

// LoanInterface defines methods for interacting with Loan resources.
type LoanInterface interface {
	Create(ctx context.Context, client Client) (*Loan, error)                // HTTP POST /api/loans
	Delete(ctx context.Context, client Client, loanID ...ID) error           // HTTP DELETE /api/loans/{id}
	Get(ctx context.Context, client Client, loanID ...ID) (*Loan, error)     // HTTP GET /api/loans/{id}
	GetItem(ctx context.Context, client Client, loanID ...ID) (*Item, error) // HTTP GET /api/loans/{id}/item
	IRI() string                                                             // /api/loans/{id}
	List(ctx context.Context, client Client) ([]*Loan, error)                // HTTP GET /api/loans
	Patch(ctx context.Context, client Client, loanID ...ID) (*Loan, error)   // HTTP PATCH /api/loans/{id}
	Update(ctx context.Context, client Client, loanID ...ID) (*Loan, error)  // HTTP PUT /api/loans/{id}
}

// Loan represents a loan record in Koillection, combining fields for JSON-LD and API interactions.
type Loan struct {
	Context    *Context   `json:"@context,omitempty" access:"rw"`   // JSON-LD only
	_ID        ID         `json:"@id,omitempty" access:"ro"`        // JSON-LD only
	Type       string     `json:"@type,omitempty" access:"rw"`      // JSON-LD only
	ID         ID         `json:"id,omitempty" access:"ro"`         // Identifier
	Item       *string    `json:"item" access:"rw"`                 // Item IRI
	LentTo     string     `json:"lentTo" access:"rw"`               // Borrower name
	LentAt     time.Time  `json:"lentAt" access:"rw"`               // Loan start date
	ReturnedAt *time.Time `json:"returnedAt,omitempty" access:"rw"` // Loan return date
	Owner      *string    `json:"owner,omitempty" access:"ro"`      // Owner IRI
}

// whichID
func (l *Loan) whichID(loanID ...ID) ID {
	if len(loanID) > 0 {
		return loanID[0]
	}
	return l.ID
}

// Create
func (l *Loan) Create(ctx context.Context, client Client) (*Loan, error) {
	return client.CreateLoan(ctx, l)
}

// Delete
func (l *Loan) Delete(ctx context.Context, client Client, loanID ...ID) error {
	id := l.whichID(loanID...)
	return client.DeleteLoan(ctx, id)
}

// Get
func (l *Loan) Get(ctx context.Context, client Client, loanID ...ID) (*Loan, error) {
	id := l.whichID(loanID...)
	return client.GetLoan(ctx, id)
}

// GetItem
func (l *Loan) GetItem(ctx context.Context, client Client, loanID ...ID) (*Item, error) {
	id := l.whichID(loanID...)
	return client.GetLoanItem(ctx, id)
}

// IRI
func (l *Loan) IRI() string {
	return fmt.Sprintf("/api/loans/%s", l.ID)
}

// List
func (l *Loan) List(ctx context.Context, client Client) ([]*Loan, error) {
	var allLoans []*Loan
	for page := 1; ; page++ {
		loans, err := client.ListLoans(ctx, page)
		if err != nil {
			return nil, fmt.Errorf("failed to list loans on page %d: %w", page, err)
		}
		if len(loans) == 0 {
			break
		}
		allLoans = append(allLoans, loans...)
	}
	return allLoans, nil
}

// Patch
func (l *Loan) Patch(ctx context.Context, client Client, loanID ...ID) (*Loan, error) {
	id := l.whichID(loanID...)
	return client.PatchLoan(ctx, id, l)
}

// Update
func (l *Loan) Update(ctx context.Context, client Client, loanID ...ID) (*Loan, error) {
	id := l.whichID(loanID...)
	return client.UpdateLoan(ctx, id, l)
}
package koiApi

import (
	"context"
	"fmt"
	"time"
)

// LogInterface defines methods for interacting with Log resources.
type LogInterface interface {
	Get(ctx context.Context, client Client, logID ...ID) (*Log, error) // HTTP GET /api/logs/{id}
	IRI() string                                                       // /api/logs/{id}
	List(ctx context.Context, client Client) ([]*Log, error)           // HTTP GET /api/logs
}

// Log represents an action or event in Koillection, combining fields for JSON-LD and API interactions.
type Log struct {
	Context       *Context  `json:"@context,omitempty" access:"rw"` // JSON-LD only
	_ID           ID        `json:"@id,omitempty" access:"ro"`      // JSON-LD only
	Type          string    `json:"@type,omitempty" access:"rw"`    // JSON-LD only
	ID            ID        `json:"id,omitempty" access:"ro"`       // Identifier
	LogType       *string   `json:"type,omitempty" access:"rw"`     // Log type
	LoggedAt      time.Time `json:"loggedAt" access:"rw"`           // Log timestamp
	ObjectID      string    `json:"objectId" access:"rw"`           // Object identifier
	ObjectLabel   string    `json:"objectLabel" access:"rw"`        // Object label
	ObjectClass   string    `json:"objectClass" access:"rw"`        // Object class
	ObjectDeleted bool      `json:"objectDeleted" access:"ro"`      // Deletion status
	Owner         *string   `json:"owner,omitempty" access:"ro"`    // Owner IRI
}

// whichID
func (l *Log) whichID(logID ...ID) ID {
	if len(logID) > 0 {
		return logID[0]
	}
	return l.ID
}

// Get
func (l *Log) Get(ctx context.Context, client Client, logID ...ID) (*Log, error) {
	id := l.whichID(logID...)
	return client.GetLog(ctx, id)
}

// IRI
func (l *Log) IRI() string {
	return fmt.Sprintf("/api/logs/%s", l.ID)
}

// List
func (l *Log) List(ctx context.Context, client Client) ([]*Log, error) {
	var allLogs []*Log
	for page := 1; ; page++ {
		logs, err := client.ListLogs(ctx, page)
		if err != nil {
			return nil, fmt.Errorf("failed to list logs on page %d: %w", page, err)
		}
		if len(logs) == 0 {
			break
		}
		allLogs = append(allLogs, logs...)
	}
	return allLogs, nil
}
package koiApi

// Metrics represents a map of metrics data.
type Metrics string // Read-only
package koiApi

import (
	"context"
	"fmt"
	"os"
	"time"
)

type PhotoImage *string

// PhotoInterface defines methods for interacting with Photo resources.
type PhotoInterface interface {
	Create(ctx context.Context, client Client) (*Photo, error)                                            // HTTP POST /api/photos
	Delete(ctx context.Context, client Client, photoID ...ID) error                                       // HTTP DELETE /api/photos/{id}
	Get(ctx context.Context, client Client, photoID ...ID) (*Photo, error)                                // HTTP GET /api/photos/{id}
	GetAlbum(ctx context.Context, client Client, photoID ...ID) (*Album, error)                           // HTTP GET /api/photos/{id}/album
	IRI() string                                                                                          // /api/photos/{id}
	List(ctx context.Context, client Client) ([]*Photo, error)                                            // HTTP GET /api/photos
	Patch(ctx context.Context, client Client, photoID ...ID) (*Photo, error)                              // HTTP PATCH /api/photos/{id}
	Update(ctx context.Context, client Client, photoID ...ID) (*Photo, error)                             // HTTP PUT /api/photos/{id}
	UploadImage(ctx context.Context, client Client, file []byte, photoID ...ID) (*Photo, error)           // HTTP POST /api/photos/{id}/image
	UploadImageByFile(ctx context.Context, client Client, filename string, photoID ...ID) (*Photo, error) // HTTP POST /api/photos/{id}/image
}

// Photo represents a photo in Koillection, combining fields for JSON-LD and API interactions.
type Photo struct {
	Context             *Context   `json:"@context,omitempty" access:"rw"`            // JSON-LD only
	_ID                 ID         `json:"@id,omitempty" access:"ro"`                 // JSON-LD only
	Type                string     `json:"@type,omitempty" access:"rw"`               // JSON-LD only
	ID                  ID         `json:"id,omitempty" access:"ro"`                  // Identifier
	Title               string     `json:"title" access:"rw"`                         // Photo title
	Comment             *string    `json:"comment,omitempty" access:"rw"`             // Photo comment
	Place               *string    `json:"place,omitempty" access:"rw"`               // Photo location
	Album               *string    `json:"album" access:"rw"`                         // Album IRI
	Owner               *string    `json:"owner,omitempty" access:"ro"`               // Owner IRI
	Image               *string    `json:"image,omitempty" access:"ro"`               // Image URL
	ImageSmallThumbnail *string    `json:"imageSmallThumbnail,omitempty" access:"ro"` // Small thumbnail URL
	TakenAt             *time.Time `json:"takenAt,omitempty" access:"ro"`             // Date taken
	Visibility          Visibility `json:"visibility,omitempty" access:"rw"`          // Visibility level
	ParentVisibility    *string    `json:"parentVisibility,omitempty" access:"ro"`    // Parent visibility
	FinalVisibility     Visibility `json:"finalVisibility,omitempty" access:"ro"`     // Effective visibility
	CreatedAt           time.Time  `json:"createdAt" access:"ro"`                     // Creation timestamp
	UpdatedAt           *time.Time `json:"updatedAt,omitempty" access:"ro"`           // Update timestamp
	File                *string    `json:"file,omitempty" access:"wo"`                // Image file data
}

// whichID
func (p *Photo) whichID(photoID ...ID) ID {
	if len(photoID) > 0 {
		return photoID[0]
	}
	return p.ID
}

// Create
func (p *Photo) Create(ctx context.Context, client Client) (*Photo, error) {
	return client.CreatePhoto(ctx, p)
}

// Delete
func (p *Photo) Delete(ctx context.Context, client Client, photoID ...ID) error {
	id := p.whichID(photoID...)
	return client.DeletePhoto(ctx, id)
}

// Get
func (p *Photo) Get(ctx context.Context, client Client, photoID ...ID) (*Photo, error) {
	id := p.whichID(photoID...)
	return client.GetPhoto(ctx, id)
}

// GetAlbum
func (p *Photo) GetAlbum(ctx context.Context, client Client, photoID ...ID) (*Album, error) {
	id := p.whichID(photoID...)
	return client.GetPhotoAlbum(ctx, id)
}

// IRI
func (p *Photo) IRI() string {
	return fmt.Sprintf("/api/photos/%s", p.ID)
}

// List
func (p *Photo) List(ctx context.Context, client Client) ([]*Photo, error) {
	var allPhotos []*Photo
	for page := 1; ; page++ {
		photos, err := client.ListPhotos(ctx, page)
		if err != nil {
			return nil, fmt.Errorf("failed to list photos on page %d: %w", page, err)
		}
		if len(photos) == 0 {
			break
		}
		allPhotos = append(allPhotos, photos...)
	}
	return allPhotos, nil
}

// Patch
func (p *Photo) Patch(ctx context.Context, client Client, photoID ...ID) (*Photo, error) {
	id := p.whichID(photoID...)
	return client.PatchPhoto(ctx, id, p)
}

// Update
func (p *Photo) Update(ctx context.Context, client Client, photoID ...ID) (*Photo, error) {
	id := p.whichID(photoID...)
	return client.UpdatePhoto(ctx, id, p)
}

// UploadImage
func (p *Photo) UploadImage(ctx context.Context, client Client, file []byte, photoID ...ID) (*Photo, error) {
	id := p.whichID(photoID...)
	return client.UploadPhotoImage(ctx, id, file)
}

// UploadImageByFile
func (p *Photo) UploadImageByFile(ctx context.Context, client Client, filename string, photoID ...ID) (*Photo, error) {
	id := p.whichID(photoID...)
	file, err := os.ReadFile(filename)
	if err != nil {
		return nil, fmt.Errorf("failed to read file %s: %w", filename, err)
	}
	return client.UploadPhotoImage(ctx, id, file)
}
package koiApi

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"strings"
)

// hasNonPrintable checks if a string contains non-printable characters (outside ASCII 32126) and returns the printable prefix and remaining length.
func hasNonPrintable(s string) (prefix string, remaining int, hasNonPrintable bool) {
	for i, r := range s {
		if r < 32 || r > 126 {
			return s[:i], len(s[i:]), true
		}
	}
	return s, 0, false
}

// sanitizeNonJSONBody returns a printable representation of a non-JSON body, using the printable prefix and a placeholder for non-printable data.
func sanitizeNonJSONBody(body string) string {
	prefix, remaining, nonPrintable := hasNonPrintable(body)
	if nonPrintable {
		if prefix == "" {
			return fmt.Sprintf("<%d bytes of binary data>", remaining)
		}
		return fmt.Sprintf("%s<%d bytes of binary data>", prefix, remaining)
	}
	return body
}

// replaceNonPrintableElements recursively inspects a JSON structure, replaces strings with non-printable characters with their printable prefix and a placeholder, and limits arrays to 3 elements.
func replaceNonPrintableElements(data interface{}) (interface{}, error) {
	switch v := data.(type) {
	case string:
		// Replace strings with non-printable characters, keeping the printable prefix.
		prefix, remaining, nonPrintable := hasNonPrintable(v)
		if nonPrintable {
			if prefix == "" {
				return fmt.Sprintf("<%d bytes of binary data>", remaining), nil
			}
			return fmt.Sprintf("%s<%d bytes of binary data>", prefix, remaining), nil
		}
		return v, nil
	case []interface{}:
		// Limit array to 3 elements.
		limit := 3
		if len(v) < limit {
			limit = len(v)
		}
		result := make([]interface{}, limit)
		for i := 0; i < limit; i++ {
			modified, err := replaceNonPrintableElements(v[i])
			if err != nil {
				return nil, err
			}
			result[i] = modified
		}
		// Check if any element is a placeholder, indicating binary data.
		for _, item := range result {
			if str, ok := item.(string); ok && strings.Contains(str, "bytes of binary data") {
				bytes, err := json.Marshal(v)
				if err != nil {
					return fmt.Sprintf("<unknown bytes of binary data>"), nil
				}
				return fmt.Sprintf("<%d bytes of binary data>", len(bytes)), nil
			}
		}
		// Add "plus N more" if array has more than 3 elements.
		if remaining := len(v) - limit; remaining > 0 {
			result = append(result, fmt.Sprintf("plus %d more", remaining))
		}
		return result, nil
	case map[string]interface{}:
		// Process map values recursively.
		result := make(map[string]interface{})
		for key, value := range v {
			modified, err := replaceNonPrintableElements(value)
			if err != nil {
				return nil, err
			}
			result[key] = modified
		}
		// Check if any value is a placeholder.
		for _, value := range result {
			if str, ok := value.(string); ok && strings.Contains(str, "bytes of binary data") {
				bytes, err := json.Marshal(v)
				if err != nil {
					return fmt.Sprintf("<unknown bytes of binary data>"), nil
				}
				return fmt.Sprintf("<%d bytes of binary data>", len(bytes)), nil
			}
		}
		return result, nil
	default:
		// Return non-string/array/map values unchanged.
		return v, nil
	}
}

// PrintError prints the request headers, request body, response headers, response body, and error struct or raw error text from the httpClient struct to stdout.
func (c *httpClient) PrintError(ctx context.Context) {
	const maxFieldSize = 1024 // Threshold for large fields in bytes.

	// Print request headers.
	fmt.Println("Request Headers:")
	if c.lastRequest == nil || len(c.lastRequest.Header) == 0 {
		fmt.Println("  No headers")
	} else {
		for key, values := range c.lastRequest.Header {
			joinedValue := strings.Join(values, ", ")
			prefix, remaining, nonPrintable := hasNonPrintable(joinedValue)
			if len(joinedValue) > maxFieldSize || nonPrintable {
				if prefix == "" {
					fmt.Printf("  %s: <%d bytes of data>\n", key, len(joinedValue))
				} else {
					fmt.Printf("  %s: %s<%d bytes of data>\n", key, prefix, remaining)
				}
			} else {
				fmt.Printf("  %s: %s\n", key, joinedValue)
			}
		}
	}

	// Print request body.
	fmt.Println("Request Body:")
	if c.lastRequestBody == nil {
		fmt.Println("  No body")
	} else {
		var jsonData interface{}
		if err := json.Unmarshal(c.lastRequestBody, &jsonData); err == nil {
			// If body is valid JSON, replace elements with non-printable characters and limit arrays.
			modifiedData, _ := replaceNonPrintableElements(jsonData)
			prettyJSON, err := json.MarshalIndent(modifiedData, "  ", "  ")
			if err == nil {
				fmt.Printf("  %s\n", string(prettyJSON))
			} else {
				fmt.Printf("  %s\n", sanitizeNonJSONBody(string(c.lastRequestBody)))
			}
		} else {
			// If not JSON, use printable prefix and placeholder.
			fmt.Printf("  %s\n", sanitizeNonJSONBody(string(c.lastRequestBody)))
		}
	}

	// Print response headers.
	fmt.Println("Response Headers:")
	if c.lastResponse == nil || len(c.lastResponse.Header) == 0 {
		fmt.Println("  No headers")
	} else {
		for key, values := range c.lastResponse.Header {
			joinedValue := strings.Join(values, ", ")
			prefix, remaining, nonPrintable := hasNonPrintable(joinedValue)
			if len(joinedValue) > maxFieldSize || nonPrintable {
				if prefix == "" {
					fmt.Printf("  %s: <%d bytes of data>\n", key, len(joinedValue))
				} else {
					fmt.Printf("  %s: %s<%d bytes of data>\n", key, prefix, remaining)
				}
			} else {
				fmt.Printf("  %s: %s\n", key, joinedValue)
			}
		}
	}

	// Print response body.
	fmt.Println("Response Body:")
	if c.rawError == "" {
		fmt.Println("  No body")
	} else {
		var jsonData interface{}
		if err := json.Unmarshal([]byte(c.rawError), &jsonData); err == nil {
			// If rawError is valid JSON, replace elements with non-printable characters and limit arrays.
			modifiedData, _ := replaceNonPrintableElements(jsonData)
			prettyJSON, err := json.MarshalIndent(modifiedData, "  ", "  ")
			if err == nil {
				fmt.Printf("  %s\n", string(prettyJSON))
			} else {
				fmt.Printf("  %s\n", sanitizeNonJSONBody(c.rawError))
			}
		} else {
			// If not JSON, use printable prefix and placeholder.
			fmt.Printf("  %s\n", sanitizeNonJSONBody(c.rawError))
		}
	}

	// Print error details.
	if c.lastResponse != nil && (c.lastResponse.StatusCode == http.StatusBadRequest || c.lastResponse.StatusCode == http.StatusUnprocessableEntity) && c.koiError == nil {
		// RawError was printed as response body for 400/422 if unmarshaling failed.
		return
	}
	if c.koiError != nil {
		fmt.Printf("Error Response (Status %d):\n", c.koiError.Status)
		fmt.Printf("  Title: %s\n", c.koiError.Title)
		fmt.Printf("  Detail: %s\n", c.koiError.Detail)
		fmt.Printf("  Description: %s\n", c.koiError.Description)
		fmt.Printf("  Context: %s\n", c.koiError.Context)
		fmt.Printf("  ID: %s\n", c.koiError.ID)
		fmt.Printf("  Type: %s\n", c.koiError.Type)
		fmt.Printf("  Instance: %s\n", c.koiError.Instance)
		if len(c.koiError.Violations) > 0 {
			fmt.Println("  Violations:")
			limit := 3
			if len(c.koiError.Violations) < limit {
				limit = len(c.koiError.Violations)
			}
			for i := 0; i < limit; i++ {
				v := c.koiError.Violations[i]
				fmt.Printf("    %d. Property: %s, Message: %s\n", i+1, v.PropertyPath, v.Message)
			}
			if remaining := len(c.koiError.Violations) - limit; remaining > 0 {
				fmt.Printf("    plus %d more\n", remaining)
			}
		}
		return
	}
	if c.rawError != "" {
		// RawError was printed as response body.
		return
	}
	fmt.Println("Error Response: No error data available")
}
package koiApi

import (
	"context"
	"fmt"
	"os"
	"reflect"
	"sort"
	"strconv"
	"strings"
	"time"

	"golang.org/x/text/currency"
	"golang.org/x/text/language"
)

// getDefaultCurrency returns the local currency based on the machine's locale or "USD" if undetermined.
func getDefaultCurrency() string {
	// Try LC_ALL or LANG environment variables
	locale := os.Getenv("LC_ALL")
	if locale == "" {
		locale = os.Getenv("LANG")
	}
	if locale != "" {
		// Parse locale (e.g., "en_US.UTF-8"  "en_US")
		parts := strings.Split(locale, ".")
		if len(parts) > 0 {
			tag, err := language.Parse(parts[0])
			if err == nil {
				region, _ := tag.Region()
				if region.IsCountry() {
					unit, ok := currency.FromRegion(region)
					if ok {
						return unit.String()
					}
				}
			}
		}
	}
	return "USD" // Default to USD
}

// validateCurrency checks if a currency code is a valid ISO 4217 code.
func validateCurrency(code string) bool {
	if code == "" {
		return false
	}
	_, err := currency.ParseISO(code)
	return err == nil
}

// validateFloat checks if a string is a valid float.
func validateFloat(value string) bool {
	if value == "" {
		return false
	}
	_, err := strconv.ParseFloat(value, 64)
	return err == nil
}

// validateStruct validates currency and price fields in a struct, setting default currency if addressable.
func validateStruct(v interface{}) error {
	val := reflect.ValueOf(v)
	if val.Kind() == reflect.Ptr {
		if val.IsNil() {
			return nil // Skip validation for nil pointers
		}
		val = val.Elem()
	}
	if val.Kind() != reflect.Struct {
		return fmt.Errorf("expected a struct or pointer to struct, got %v", val.Kind())
	}

	// Ensure the struct is addressable for modifications
	if !val.CanSet() {
		return fmt.Errorf("struct %v is not addressable; pass a pointer to modify currency fields", val.Type().Name())
	}

	typ := val.Type()
	defaultCurrency := getDefaultCurrency()

	switch typ.Name() {
	case "User":
		currencyField := val.FieldByName("Currency")
		if !currencyField.IsValid() {
			return fmt.Errorf("User.Currency field not found")
		}
		if currencyField.String() == "" && currencyField.CanSet() {
			currencyField.SetString(defaultCurrency)
		}
		if !validateCurrency(currencyField.String()) {
			return fmt.Errorf("invalid ISO 4217 currency code for User.Currency: %s", currencyField.String())
		}
	case "Datum":
		datumTypeField := val.FieldByName("DatumType")
		currencyField := val.FieldByName("Currency")
		valueField := val.FieldByName("Value")
		if !datumTypeField.IsValid() || !currencyField.IsValid() || !valueField.IsValid() {
			return fmt.Errorf("Datum fields (DatumType, Currency, Value) not found")
		}
		if datumTypeField.String() == "price" {
			if currencyField.IsNil() && currencyField.CanSet() {
				currencyField.Set(reflect.ValueOf(&defaultCurrency))
			} else if !currencyField.IsNil() && !validateCurrency(*currencyField.Interface().(*string)) {
				return fmt.Errorf("invalid ISO 4217 currency code for Datum.Currency: %s", *currencyField.Interface().(*string))
			}
			if valueField.IsNil() {
				return fmt.Errorf("Datum.Value must be set for price type")
			}
			if !validateFloat(*valueField.Interface().(*string)) {
				return fmt.Errorf("invalid float for Datum.Value (price): %s", *valueField.Interface().(*string))
			}
		}
	case "Wish":
		currencyField := val.FieldByName("Currency")
		priceField := val.FieldByName("Price")
		if !currencyField.IsValid() || !priceField.IsValid() {
			return fmt.Errorf("Wish fields (Currency, Price) not found")
		}
		if currencyField.IsNil() && priceField.IsValid() && !priceField.IsNil() && currencyField.CanSet() {
			currencyField.Set(reflect.ValueOf(&defaultCurrency))
		} else if !currencyField.IsNil() && !validateCurrency(*currencyField.Interface().(*string)) {
			return fmt.Errorf("invalid ISO 4217 currency code for Wish.Currency: %s", *currencyField.Interface().(*string))
		}
		if priceField.IsValid() && !priceField.IsNil() && !validateFloat(*priceField.Interface().(*string)) {
			return fmt.Errorf("invalid float in Wish.Price: %s", *priceField.Interface().(*string))
		}
	}

	return nil
}

// printStruct generically prints the fields of a struct using reflection, aligning values at the same left margin,
// skipping fields tagged with omitempty if their values would be omitted in JSON marshaling. For Datum in non-verbose
// mode, only DatumType, Label, and Value (if non-nil) are printed. Uses the specified indent level for field lines.
func printStruct(v interface{}, indentLevel int, verbose bool, format string, args ...interface{}) (int, error) {
	if v == nil {
		fmt.Println("<nil>")
		return 0, nil
	}

	// Validate currency and price fields before printing
	if err := validateStruct(v); err != nil {
		return 0, err
	}

	// Get the value and dereference if it's a pointer
	val := reflect.ValueOf(v)
	if val.Kind() == reflect.Ptr {
		if val.IsNil() {
			fmt.Println("<nil>")
			return 0, nil
		}
		val = val.Elem()
	}
	if val.Kind() != reflect.Struct {
		return 0, fmt.Errorf("expected a struct or pointer to struct, got %v", val.Kind())
	}

	typ := val.Type()
	numFields := val.NumField()

	// Print the formatted header
	if format != "" {
		fmt.Printf(format, args...)
	} else {
		fmt.Printf("%s\n", typ.Name())
	}

	if numFields == 0 {
		fmt.Printf("%s%s: <empty>\n", strings.Repeat(" ", indentLevel), typ.Name())
		return 0, nil
	}

	// Determine fields to print
	var fieldsToPrint []int
	if !verbose && typ.Name() == "Datum" {
		for i := 0; i < numFields; i++ {
			name := typ.Field(i).Name
			if name == "DatumType" || name == "Label" || (name == "Value" && !val.Field(i).IsNil()) {
				fieldsToPrint = append(fieldsToPrint, i)
			}
		}
	} else {
		for i := 0; i < numFields; i++ {
			if jsonTag := typ.Field(i).Tag.Get("json"); strings.Contains(jsonTag, ",omitempty") {
				field := val.Field(i)
				switch field.Kind() {
				case reflect.Ptr:
					if field.IsNil() {
						continue
					}
				case reflect.Slice:
					if field.IsNil() || field.Len() == 0 {
						continue
					}
				case reflect.String:
					if field.String() == "" {
						continue
					}
				case reflect.Int:
					if field.Int() == 0 {
						continue
					}
				case reflect.Bool:
					if !field.Bool() {
						continue
					}
				case reflect.Struct:
					if field.Type() == reflect.TypeOf(time.Time{}) && field.Interface().(time.Time).IsZero() {
						continue
					}
				}
			}
			fieldsToPrint = append(fieldsToPrint, i)
		}
	}

	if len(fieldsToPrint) == 0 {
		fmt.Printf("%s%s: <empty>\n", strings.Repeat(" ", indentLevel), typ.Name())
		return 0, nil
	}

	// Calculate max field name length for alignment
	maxLen := 0
	for _, i := range fieldsToPrint {
		name := typ.Field(i).Name
		if len(name) > maxLen {
			maxLen = len(name)
		}
	}

	// Print fields with aligned values, indented by indentLevel spaces
	printedFields := 0
	for _, i := range fieldsToPrint {
		field := val.Field(i)
		fieldType := typ.Field(i)
		name := fieldType.Name
		//jsonTag := fieldType.Tag.Get("json")

		// Check for non-compliant currency fields from server
		if (typ.Name() == "User" && name == "Currency") ||
			((typ.Name() == "Datum" || typ.Name() == "Wish") && name == "Currency") {
			if field.Kind() == reflect.String && field.String() != "" && !validateCurrency(field.String()) {
				fmt.Printf("%sWARNING: Invalid currency code '%s' for %s.%s\n", strings.Repeat(" ", indentLevel), field.String(), typ.Name(), name)
			} else if field.Kind() == reflect.Ptr && !field.IsNil() && !validateCurrency(field.Elem().String()) {
				fmt.Printf("%sWARNING: Invalid currency code '%s' for %s.%s\n", strings.Repeat(" ", indentLevel), field.Elem().String(), typ.Name(), name)
			}
		}
		if (typ.Name() == "Datum" && name == "Value" && val.FieldByName("DatumType").String() == "price") ||
			(typ.Name() == "Wish" && name == "Price") {
			if field.Kind() == reflect.Ptr && !field.IsNil() && !validateFloat(field.Elem().String()) {
				fmt.Printf("%sWARNING: Invalid float value '%s' for %s.%s\n", strings.Repeat(" ", indentLevel), field.Elem().String(), typ.Name(), name)
			}
		}

		prefix := strings.Repeat(" ", indentLevel) + typ.Name() + "." + name
		padding := strings.Repeat(" ", maxLen-len(name)+1)

		switch field.Kind() {
		case reflect.Ptr:
			if field.IsNil() {
				fmt.Printf("%s:%s<nil>\n", prefix, padding)
			} else {
				switch field.Type().Elem().Kind() {
				case reflect.String:
					fmt.Printf("%s:%s%s\n", prefix, padding, field.Elem().String())
				case reflect.Int:
					fmt.Printf("%s:%s%d\n", prefix, padding, field.Elem().Int())
				case reflect.Bool:
					fmt.Printf("%s:%s%t\n", prefix, padding, field.Elem().Bool())
				case reflect.Struct:
					if field.Type().Elem() == reflect.TypeOf(time.Time{}) {
						fmt.Printf("%s:%s%v\n", prefix, padding, field.Elem().Interface())
					} else {
						fmt.Printf("%s:%s%v\n", prefix, padding, field.Elem().String())
					}
				default:
					fmt.Printf("%s:%s%v\n", prefix, padding, field.Elem().Interface())
				}
			}
		case reflect.Slice:
			if field.IsNil() {
				fmt.Printf("%s:%s[]\n", prefix, padding)
			} else {
				fmt.Printf("%s:%s%v\n", prefix, padding, field.Interface())
			}
		default:
			switch field.Kind() {
			case reflect.String:
				fmt.Printf("%s:%s%s\n", prefix, padding, field.String())
			case reflect.Int:
				fmt.Printf("%s:%s%d\n", prefix, padding, field.Int())
			case reflect.Bool:
				fmt.Printf("%s:%s%t\n", prefix, padding, field.Bool())
			case reflect.Struct:
				if field.Type() == reflect.TypeOf(time.Time{}) {
					fmt.Printf("%s:%s%v\n", prefix, padding, field.Interface())
				} else {
					fmt.Printf("%s:%s%v\n", prefix, padding, field.String())
				}
			default:
				fmt.Printf("%s:%s%v\n", prefix, padding, field.Interface())
			}
		}
		printedFields++
	}

	return printedFields, nil
}

// GetItemAndData retrieves an Item and all associated Datum objects using the Client.
func GetItemAndData(ctx context.Context, client Client, itemID ID) (*Item, []*Datum, error) {
	// Fetch the Item
	item, err := client.GetItem(ctx, itemID)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to get item %s: %w", itemID, err)
	}

	// Fetch all Datum objects associated with the item
	data, err := client.ListItemData(ctx, itemID, 1)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to get data for item %s: %w", itemID, err)
	}

	// Handle pagination if more data exists
	var allData []*Datum
	allData = append(allData, data...)
	for page := 2; len(data) > 0; page++ {
		data, err = client.ListItemData(ctx, itemID, page)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to get data page %d for item %s: %w", page, itemID, err)
		}
		allData = append(allData, data...)
	}

	return item, allData, nil
}

// PrintItemWithData prints the fields of an Item and all associated Datum objects, indenting Datum fields further.
// Datum items are sorted by Position (ascending, with nil/negative at end). In non-verbose mode, only DatumType,
// Label, and Value (if non-nil) are printed for Datum.
func PrintItemWithData(item *Item, data []*Datum, verbose bool, format string, args ...interface{}) (int, error) {
	totalFields := 0

	// Print the formatted header
	if format != "" {
		fmt.Printf(format, args...)
	} else {
		fmt.Println("Item")
	}

	// Print Item fields with 4-space indent
	if item == nil {
		fmt.Println("    Item: <nil>")
	} else {
		itemFields, err := printStruct(item, 4, true, "")
		if err != nil {
			return 0, fmt.Errorf("failed to print item: %w", err)
		}
		totalFields += itemFields
	}

	// Sort Datum by Position (nil/negative to end)
	sortedData := make([]*Datum, len(data))
	copy(sortedData, data)
	sort.SliceStable(sortedData, func(i, j int) bool {
		posI, posJ := sortedData[i].Position, sortedData[j].Position
		if posI == nil || *posI < 0 {
			return false // i is invalid, sort to end
		}
		if posJ == nil || *posJ < 0 {
			return true // j is invalid, sort to end
		}
		return *posI < *posJ
	})

	// Print each Datum with 8-space indent
	for i, datum := range sortedData {
		if datum == nil {
			fmt.Printf("        Datum[%d]: <nil>\n", i)
			continue
		}
		datumFields, err := printStruct(datum, 8, verbose, "        Datum[%d]\n", i)
		if err != nil {
			return totalFields, fmt.Errorf("failed to print datum %d: %w", i, err)
		}
		totalFields += datumFields
	}

	return totalFields, nil
}

// Print methods for each struct type
func (a Album) Print(format string, args ...interface{}) (int, error) {
	return printStruct(&a, 4, true, format, args...)
}

func (c ChoiceList) Print(format string, args ...interface{}) (int, error) {
	return printStruct(&c, 4, true, format, args...)
}

func (c Collection) Print(format string, args ...interface{}) (int, error) {
	return printStruct(&c, 4, true, format, args...)
}

func (d Datum) Print(format string, args ...interface{}) (int, error) {
	return printStruct(&d, 4, true, format, args...)
}

func (f Field) Print(format string, args ...interface{}) (int, error) {
	return printStruct(&f, 4, true, format, args...)
}

func (i Inventory) Print(format string, args ...interface{}) (int, error) {
	return printStruct(&i, 4, true, format, args...)
}

func (i Item) Print(format string, args ...interface{}) (int, error) {
	return printStruct(&i, 4, true, format, args...)
}

func (l Loan) Print(format string, args ...interface{}) (int, error) {
	return printStruct(&l, 4, true, format, args...)
}

func (l Log) Print(format string, args ...interface{}) (int, error) {
	return printStruct(&l, 4, true, format, args...)
}

func (p Photo) Print(format string, args ...interface{}) (int, error) {
	return printStruct(&p, 4, true, format, args...)
}

func (t Tag) Print(format string, args ...interface{}) (int, error) {
	return printStruct(&t, 4, true, format, args...)
}

func (tc TagCategory) Print(format string, args ...interface{}) (int, error) {
	return printStruct(&tc, 4, true, format, args...)
}

func (t Template) Print(format string, args ...interface{}) (int, error) {
	return printStruct(&t, 4, true, format, args...)
}

func (u User) Print(format string, args ...interface{}) (int, error) {
	return printStruct(&u, 4, true, format, args...)
}

func (w Wish) Print(format string, args ...interface{}) (int, error) {
	return printStruct(&w, 4, true, format, args...)
}

func (w Wishlist) Print(format string, args ...interface{}) (int, error) {
	return printStruct(&w, 4, true, format, args...)
}
package koiApi

import (
	"context"
	"fmt"
	"os"
	"time"
)

// TagInterface defines methods for interacting with Tag resources.
type TagInterface interface {
	Create(ctx context.Context, client Client) (*Tag, error)                                          // HTTP POST /api/tags
	Delete(ctx context.Context, client Client, tagID ...ID) error                                     // HTTP DELETE /api/tags/{id}
	Get(ctx context.Context, client Client, tagID ...ID) (*Tag, error)                                // HTTP GET /api/tags/{id}
	GetCategory(ctx context.Context, client Client, tagID ...ID) (*TagCategory, error)                // HTTP GET /api/tags/{id}/category
	IRI() string                                                                                      // /api/tags/{id}
	List(ctx context.Context, client Client) ([]*Tag, error)                                          // HTTP GET /api/tags
	ListItems(ctx context.Context, client Client, tagID ...ID) ([]*Item, error)                       // HTTP GET /api/tags/{id}/items
	Patch(ctx context.Context, client Client, tagID ...ID) (*Tag, error)                              // HTTP PATCH /api/tags/{id}
	Update(ctx context.Context, client Client, tagID ...ID) (*Tag, error)                             // HTTP PUT /api/tags/{id}
	UploadImage(ctx context.Context, client Client, file []byte, tagID ...ID) (*Tag, error)           // HTTP POST /api/tags/{id}/image
	UploadImageByFile(ctx context.Context, client Client, filename string, tagID ...ID) (*Tag, error) // HTTP POST /api/tags/{id}/image
}

// Tag represents a tag in Koillection, combining fields for JSON-LD and API interactions.
type Tag struct {
	Context             *Context   `json:"@context,omitempty" access:"rw"`            // JSON-LD only
	_ID                 ID         `json:"@id,omitempty" access:"ro"`                 // JSON-LD only
	Type                string     `json:"@type,omitempty" access:"rw"`               // JSON-LD only
	ID                  ID         `json:"id,omitempty" access:"ro"`                  // Identifier
	Label               string     `json:"label" access:"rw"`                         // Tag label
	Description         *string    `json:"description,omitempty" access:"rw"`         // Tag description
	Image               *string    `json:"image,omitempty" access:"ro"`               // Image URL
	ImageSmallThumbnail *string    `json:"imageSmallThumbnail,omitempty" access:"ro"` // Small thumbnail URL
	Owner               *string    `json:"owner,omitempty" access:"ro"`               // Owner IRI
	Category            *string    `json:"category,omitempty" access:"rw"`            // Category IRI
	SeenCounter         int        `json:"seenCounter,omitempty" access:"ro"`         // View count
	Visibility          Visibility `json:"visibility,omitempty" access:"rw"`          // Visibility level
	CreatedAt           time.Time  `json:"createdAt" access:"ro"`                     // Creation timestamp
	UpdatedAt           *time.Time `json:"updatedAt,omitempty" access:"ro"`           // Update timestamp
	File                *string    `json:"file,omitempty" access:"wo"`                // Image file data
}

// whichID
func (t *Tag) whichID(tagID ...ID) ID {
	if len(tagID) > 0 {
		return tagID[0]
	}
	return t.ID
}

// Create
func (t *Tag) Create(ctx context.Context, client Client) (*Tag, error) {
	return client.CreateTag(ctx, t)
}

// Delete
func (t *Tag) Delete(ctx context.Context, client Client, tagID ...ID) error {
	id := t.whichID(tagID...)
	return client.DeleteTag(ctx, id)
}

// Get
func (t *Tag) Get(ctx context.Context, client Client, tagID ...ID) (*Tag, error) {
	id := t.whichID(tagID...)
	return client.GetTag(ctx, id)
}

// GetCategory
func (t *Tag) GetCategory(ctx context.Context, client Client, tagID ...ID) (*TagCategory, error) {
	id := t.whichID(tagID...)
	return client.GetCategoryOfTag(ctx, id)
}

// IRI
func (t *Tag) IRI() string {
	return fmt.Sprintf("/api/tags/%s", t.ID)
}

// List
func (t *Tag) List(ctx context.Context, client Client) ([]*Tag, error) {
	var allTags []*Tag
	for page := 1; ; page++ {
		tags, err := client.ListTags(ctx, page)
		if err != nil {
			return nil, fmt.Errorf("failed to list tags on page %d: %w", page, err)
		}
		if len(tags) == 0 {
			break
		}
		allTags = append(allTags, tags...)
	}
	return allTags, nil
}

// ListItems
func (t *Tag) ListItems(ctx context.Context, client Client, tagID ...ID) ([]*Item, error) {
	id := t.whichID(tagID...)
	var allItems []*Item
	for page := 1; ; page++ {
		items, err := client.ListTagItems(ctx, id, page)
		if err != nil {
			return nil, fmt.Errorf("failed to list items for ID %s on page %d: %w", id, page, err)
		}
		if len(items) == 0 {
			break
		}
		allItems = append(allItems, items...)
	}
	return allItems, nil
}

// Patch
func (t *Tag) Patch(ctx context.Context, client Client, tagID ...ID) (*Tag, error) {
	id := t.whichID(tagID...)
	return client.PatchTag(ctx, id, t)
}

// Update
func (t *Tag) Update(ctx context.Context, client Client, tagID ...ID) (*Tag, error) {
	id := t.whichID(tagID...)
	return client.UpdateTag(ctx, id, t)
}

// UploadImage
func (t *Tag) UploadImage(ctx context.Context, client Client, file []byte, tagID ...ID) (*Tag, error) {
	id := t.whichID(tagID...)
	return client.UploadTagImage(ctx, id, file)
}

// UploadImageByFile
func (t *Tag) UploadImageByFile(ctx context.Context, client Client, filename string, tagID ...ID) (*Tag, error) {
	id := t.whichID(tagID...)
	file, err := os.ReadFile(filename)
	if err != nil {
		return nil, fmt.Errorf("failed to read file %s: %w", filename, err)
	}
	return client.UploadTagImage(ctx, id, file)
}
package koiApi

import (
	"context"
	"fmt"
	"time"
)

// TagCategoryInterface defines methods for interacting with TagCategory resources.
type TagCategoryInterface interface {
	Create(ctx context.Context, client Client) (*TagCategory, error)                      // HTTP POST /api/tag_categories
	Delete(ctx context.Context, client Client, tagCategoryID ...ID) error                 // HTTP DELETE /api/tag_categories/{id}
	Get(ctx context.Context, client Client, tagCategoryID ...ID) (*TagCategory, error)    // HTTP GET /api/tag_categories/{id}
	IRI() string                                                                          // /api/tag_categories/{id}
	List(ctx context.Context, client Client) ([]*TagCategory, error)                      // HTTP GET /api/tag_categories
	ListTags(ctx context.Context, client Client, tagCategoryID ...ID) ([]*Tag, error)     // HTTP GET /api/tag_categories/{id}/tags
	Patch(ctx context.Context, client Client, tagCategoryID ...ID) (*TagCategory, error)  // HTTP PATCH /api/tag_categories/{id}
	Update(ctx context.Context, client Client, tagCategoryID ...ID) (*TagCategory, error) // HTTP PUT /api/tag_categories/{id}
}

// TagCategory represents a tag category in Koillection, combining fields for JSON-LD and API interactions.
type TagCategory struct {
	Context     *Context   `json:"@context,omitempty" access:"rw"`    // JSON-LD only
	_ID         ID         `json:"@id,omitempty" access:"ro"`         // JSON-LD only
	Type        string     `json:"@type,omitempty" access:"rw"`       // JSON-LD only
	ID          ID         `json:"id,omitempty" access:"ro"`          // Identifier
	Label       string     `json:"label" access:"rw"`                 // Category label
	Description *string    `json:"description,omitempty" access:"rw"` // Category description
	Color       string     `json:"color" access:"rw"`                 // Color code
	Owner       *string    `json:"owner,omitempty" access:"ro"`       // Owner IRI
	CreatedAt   time.Time  `json:"createdAt" access:"ro"`             // Creation timestamp
	UpdatedAt   *time.Time `json:"updatedAt,omitempty" access:"ro"`   // Update timestamp
}

// whichID
func (tc *TagCategory) whichID(tagCategoryID ...ID) ID {
	if len(tagCategoryID) > 0 {
		return tagCategoryID[0]
	}
	return tc.ID
}

// Create
func (tc *TagCategory) Create(ctx context.Context, client Client) (*TagCategory, error) {
	return client.CreateTagCategory(ctx, tc)
}

// Delete
func (tc *TagCategory) Delete(ctx context.Context, client Client, tagCategoryID ...ID) error {
	id := tc.whichID(tagCategoryID...)
	return client.DeleteTagCategory(ctx, id)
}

// Get
func (tc *TagCategory) Get(ctx context.Context, client Client, tagCategoryID ...ID) (*TagCategory, error) {
	id := tc.whichID(tagCategoryID...)
	return client.GetTagCategory(ctx, id)
}

// IRI
func (tc *TagCategory) IRI() string {
	return fmt.Sprintf("/api/tag_categories/%s", tc.ID)
}

// List
func (tc *TagCategory) List(ctx context.Context, client Client) ([]*TagCategory, error) {
	var allTagCategories []*TagCategory
	for page := 1; ; page++ {
		tagCategories, err := client.ListTagCategories(ctx, page)
		if err != nil {
			return nil, fmt.Errorf("failed to list tag categories on page %d: %w", page, err)
		}
		if len(tagCategories) == 0 {
			break
		}
		allTagCategories = append(allTagCategories, tagCategories...)
	}
	return allTagCategories, nil
}

// ListTags
func (tc *TagCategory) ListTags(ctx context.Context, client Client, tagCategoryID ...ID) ([]*Tag, error) {
	id := tc.whichID(tagCategoryID...)
	var allTags []*Tag
	for page := 1; ; page++ {
		tags, err := client.ListTagCategoryTags(ctx, id, page)
		if err != nil {
			return nil, fmt.Errorf("failed to list tags for ID %s on page %d: %w", id, page, err)
		}
		if len(tags) == 0 {
			break
		}
		allTags = append(allTags, tags...)
	}
	return allTags, nil
}

// Patch
func (tc *TagCategory) Patch(ctx context.Context, client Client, tagCategoryID ...ID) (*TagCategory, error) {
	id := tc.whichID(tagCategoryID...)
	return client.PatchTagCategory(ctx, id, tc)
}

// Update
func (tc *TagCategory) Update(ctx context.Context, client Client, tagCategoryID ...ID) (*TagCategory, error) {
	id := tc.whichID(tagCategoryID...)
	return client.UpdateTagCategory(ctx, id, tc)
}
package koiApi

import (
	"context"
	"fmt"
	"time"
)

// TemplateInterface defines methods for interacting with Template resources.
type TemplateInterface interface {
	Create(ctx context.Context, client Client) (*Template, error)                   // HTTP POST /api/templates
	Delete(ctx context.Context, client Client, templateID ...ID) error              // HTTP DELETE /api/templates/{id}
	Get(ctx context.Context, client Client, templateID ...ID) (*Template, error)    // HTTP GET /api/templates/{id}
	IRI() string                                                                    // /api/templates/{id}
	List(ctx context.Context, client Client) ([]*Template, error)                   // HTTP GET /api/templates
	Patch(ctx context.Context, client Client, templateID ...ID) (*Template, error)  // HTTP PATCH /api/templates/{id}
	Update(ctx context.Context, client Client, templateID ...ID) (*Template, error) // HTTP PUT /api/templates/{id}
}

// Template represents a template in Koillection, combining fields for JSON-LD and API interactions.
type Template struct {
	Context   *Context   `json:"@context,omitempty" access:"rw"`  // JSON-LD only
	_ID       ID         `json:"@id,omitempty" access:"ro"`       // JSON-LD only
	Type      string     `json:"@type,omitempty" access:"rw"`     // JSON-LD only
	ID        ID         `json:"id,omitempty" access:"ro"`        // Identifier
	Name      string     `json:"name" access:"rw"`                // Template name
	Owner     *string    `json:"owner,omitempty" access:"ro"`     // Owner IRI
	CreatedAt time.Time  `json:"createdAt" access:"ro"`           // Creation timestamp
	UpdatedAt *time.Time `json:"updatedAt,omitempty" access:"ro"` // Update timestamp
}

// whichID
func (t *Template) whichID(templateID ...ID) ID {
	if len(templateID) > 0 {
		return templateID[0]
	}
	return t.ID
}

// Create
func (t *Template) Create(ctx context.Context, client Client) (*Template, error) {
	return client.CreateTemplate(ctx, t)
}

// Delete
func (t *Template) Delete(ctx context.Context, client Client, templateID ...ID) error {
	id := t.whichID(templateID...)
	return client.DeleteTemplate(ctx, id)
}

// Get
func (t *Template) Get(ctx context.Context, client Client, templateID ...ID) (*Template, error) {
	id := t.whichID(templateID...)
	return client.GetTemplate(ctx, id)
}

// IRI
func (t *Template) IRI() string {
	return fmt.Sprintf("/api/templates/%s", t.ID)
}

// List
func (t *Template) List(ctx context.Context, client Client) ([]*Template, error) {
	var allTemplates []*Template
	for page := 1; ; page++ {
		templates, err := client.ListTemplates(ctx, page)
		if err != nil {
			return nil, fmt.Errorf("failed to list templates on page %d: %w", page, err)
		}
		if len(templates) == 0 {
			break
		}
		allTemplates = append(allTemplates, templates...)
	}
	return allTemplates, nil
}

// Patch
func (t *Template) Patch(ctx context.Context, client Client, templateID ...ID) (*Template, error) {
	id := t.whichID(templateID...)
	return client.PatchTemplate(ctx, id, t)
}

// Update
func (t *Template) Update(ctx context.Context, client Client, templateID ...ID) (*Template, error) {
	id := t.whichID(templateID...)
	return client.UpdateTemplate(ctx, id, t)
}
package koiApi

import (
	"context"
	"fmt"
	"time"
)

// UserInterface defines methods for interacting with User resources.
type UserInterface interface {
	Get(ctx context.Context, client Client, userID ...ID) (*User, error) // HTTP GET /api/users/{id}
	IRI() string                                                         // /api/users/{id}
	List(ctx context.Context, client Client) ([]*User, error)            // HTTP GET /api/users
}

// User represents a user in Koillection, combining fields for JSON-LD and API interactions.
type User struct {
	Context                      *Context   `json:"@context,omitempty" access:"rw"`           // JSON-LD only
	_ID                          ID         `json:"@id,omitempty" access:"ro"`                // JSON-LD only
	Type                         string     `json:"@type,omitempty" access:"rw"`              // JSON-LD only
	ID                           ID         `json:"id,omitempty" access:"ro"`                 // Identifier
	Username                     string     `json:"username" access:"rw"`                     // User name
	Email                        string     `json:"email" access:"rw"`                        // Email address
	PlainPassword                *string    `json:"plainPassword,omitempty" access:"rw"`      // Password
	Avatar                       *string    `json:"avatar,omitempty" access:"rw"`             // Avatar URL
	Currency                     string     `json:"currency" access:"rw"`                     // Currency preference
	Locale                       string     `json:"locale" access:"rw"`                       // Language preference
	Timezone                     string     `json:"timezone" access:"rw"`                     // Timezone preference
	DateFormat                   DateFormat `json:"dateFormat" access:"rw"`                   // Date format preference
	DiskSpaceAllowed             int        `json:"diskSpaceAllowed" access:"rw"`             // Storage limit
	Visibility                   Visibility `json:"visibility" access:"rw"`                   // Visibility level
	LastDateOfActivity           *time.Time `json:"lastDateOfActivity,omitempty" access:"ro"` // Last activity timestamp
	WishlistsFeatureEnabled      bool       `json:"wishlistsFeatureEnabled" access:"rw"`      // Wishlists feature toggle
	TagsFeatureEnabled           bool       `json:"tagsFeatureEnabled" access:"rw"`           // Tags feature toggle
	SignsFeatureEnabled          bool       `json:"signsFeatureEnabled" access:"rw"`          // Signs feature toggle
	AlbumsFeatureEnabled         bool       `json:"albumsFeatureEnabled" access:"rw"`         // Albums feature toggle
	LoansFeatureEnabled          bool       `json:"loansFeatureEnabled" access:"rw"`          // Loans feature toggle
	TemplatesFeatureEnabled      bool       `json:"templatesFeatureEnabled" access:"rw"`      // Templates feature toggle
	HistoryFeatureEnabled        bool       `json:"historyFeatureEnabled" access:"rw"`        // History feature toggle
	StatisticsFeatureEnabled     bool       `json:"statisticsFeatureEnabled" access:"rw"`     // Statistics feature toggle
	ScrapingFeatureEnabled       bool       `json:"scrapingFeatureEnabled" access:"rw"`       // Scraping feature toggle
	SearchInDataByDefaultEnabled bool       `json:"searchInDataByDefaultEnabled" access:"rw"` // Search data toggle
	DisplayItemsNameInGridView   bool       `json:"displayItemsNameInGridView" access:"rw"`   // Grid view name toggle
	SearchResultsDisplayMode     string     `json:"searchResultsDisplayMode" access:"rw"`     // Search display mode
	CreatedAt                    time.Time  `json:"createdAt" access:"ro"`                    // Creation timestamp
	UpdatedAt                    *time.Time `json:"updatedAt,omitempty" access:"ro"`          // Update timestamp
}

// whichID
func (u *User) whichID(userID ...ID) ID {
	if len(userID) > 0 {
		return userID[0]
	}
	return u.ID
}

// Get
func (u *User) Get(ctx context.Context, client Client, userID ...ID) (*User, error) {
	id := u.whichID(userID...)
	return client.GetUser(ctx, id)
}

// IRI
func (u *User) IRI() string {
	return fmt.Sprintf("/api/users/%s", u.ID)
}

// List
func (u *User) List(ctx context.Context, client Client) ([]*User, error) {
	var allUsers []*User
	for page := 1; ; page++ {
		users, err := client.ListUsers(ctx, page)
		if err != nil {
			return nil, fmt.Errorf("failed to list users on page %d: %w", page, err)
		}
		if len(users) == 0 {
			break
		}
		allUsers = append(allUsers, users...)
	}
	return allUsers, nil
}
package koiApi

// Visibility represents the visibility level of a resource.
type Visibility string // Read and write

const (
	VisibilityPublic   Visibility = "public" // Default for most resources
	VisibilityInternal Visibility = "internal"
	VisibilityPrivate  Visibility = "private" // Default for User
)

func (v Visibility) String() string {
	return string(v)
}
package koiApi

import (
	"context"
	"fmt"
	"os"
	"time"
)

// WishInterface defines methods for interacting with Wish resources.
type WishInterface interface {
	Create(ctx context.Context, client Client) (*Wish, error)                                           // HTTP POST /api/wishes
	Delete(ctx context.Context, client Client, wishID ...ID) error                                      // HTTP DELETE /api/wishes/{id}
	Get(ctx context.Context, client Client, wishID ...ID) (*Wish, error)                                // HTTP GET /api/wishes/{id}
	GetWishlist(ctx context.Context, client Client, wishID ...ID) (*Wishlist, error)                    // HTTP GET /api/wishes/{id}/wishlist
	IRI() string                                                                                        // /api/wishes/{id}
	List(ctx context.Context, client Client) ([]*Wish, error)                                           // HTTP GET /api/wishes
	Patch(ctx context.Context, client Client, wishID ...ID) (*Wish, error)                              // HTTP PATCH /api/wishes/{id}
	Update(ctx context.Context, client Client, wishID ...ID) (*Wish, error)                             // HTTP PUT /api/wishes/{id}
	UploadImage(ctx context.Context, client Client, file []byte, wishID ...ID) (*Wish, error)           // HTTP POST /api/wishes/{id}/image
	UploadImageByFile(ctx context.Context, client Client, filename string, wishID ...ID) (*Wish, error) // HTTP POST /api/wishes/{id}/image
}

// Wish represents a wish in Koillection, combining fields for JSON-LD and API interactions.
type Wish struct {
	Context             *Context   `json:"@context,omitempty" access:"rw"`            // JSON-LD only
	_ID                 ID         `json:"@id,omitempty" access:"ro"`                 // JSON-LD only
	Type                string     `json:"@type,omitempty" access:"rw"`               // JSON-LD only
	ID                  ID         `json:"id,omitempty" access:"ro"`                  // Identifier
	Name                string     `json:"name" access:"rw"`                          // Wish name
	URL                 *string    `json:"url,omitempty" access:"rw"`                 // Wish URL
	Price               *string    `json:"price,omitempty" access:"rw"`               // Wish price
	Currency            *string    `json:"currency,omitempty" access:"rw"`            // Currency code
	Wishlist            *string    `json:"wishlist" access:"rw"`                      // Wishlist IRI
	Owner               *string    `json:"owner,omitempty" access:"ro"`               // Owner IRI
	Comment             *string    `json:"comment,omitempty" access:"rw"`             // Wish comment
	Image               *string    `json:"image,omitempty" access:"ro"`               // Image URL
	ImageSmallThumbnail *string    `json:"imageSmallThumbnail,omitempty" access:"ro"` // Small thumbnail URL
	Visibility          Visibility `json:"visibility,omitempty" access:"rw"`          // Visibility level
	ParentVisibility    *string    `json:"parentVisibility,omitempty" access:"ro"`    // Parent visibility
	FinalVisibility     Visibility `json:"finalVisibility,omitempty" access:"ro"`     // Effective visibility
	ScrapedFromURL      *string    `json:"scrapedFromUrl,omitempty" access:"ro"`      // Source URL
	CreatedAt           time.Time  `json:"createdAt" access:"ro"`                     // Creation timestamp
	UpdatedAt           *time.Time `json:"updatedAt,omitempty" access:"ro"`           // Update timestamp
	File                *string    `json:"file,omitempty" access:"wo"`                // Image file data
}

// whichID
func (w *Wish) whichID(wishID ...ID) ID {
	if len(wishID) > 0 {
		return wishID[0]
	}
	return w.ID
}

// Create
func (w *Wish) Create(ctx context.Context, client Client) (*Wish, error) {
	return client.CreateWish(ctx, w)
}

// Delete
func (w *Wish) Delete(ctx context.Context, client Client, wishID ...ID) error {
	id := w.whichID(wishID...)
	return client.DeleteWish(ctx, id)
}

// Get
func (w *Wish) Get(ctx context.Context, client Client, wishID ...ID) (*Wish, error) {
	id := w.whichID(wishID...)
	return client.GetWish(ctx, id)
}

// GetWishlist
func (w *Wish) GetWishlist(ctx context.Context, client Client, wishID ...ID) (*Wishlist, error) {
	id := w.whichID(wishID...)
	return client.GetWishWishlist(ctx, id)
}

// IRI
func (w *Wish) IRI() string {
	return fmt.Sprintf("/api/wishes/%s", w.ID)
}

// List
func (w *Wish) List(ctx context.Context, client Client) ([]*Wish, error) {
	var allWishes []*Wish
	for page := 1; ; page++ {
		wishes, err := client.ListWishes(ctx, page)
		if err != nil {
			return nil, fmt.Errorf("failed to list wishes on page %d: %w", page, err)
		}
		if len(wishes) == 0 {
			break
		}
		allWishes = append(allWishes, wishes...)
	}
	return allWishes, nil
}

// Patch
func (w *Wish) Patch(ctx context.Context, client Client, wishID ...ID) (*Wish, error) {
	id := w.whichID(wishID...)
	return client.PatchWish(ctx, id, w)
}

// Update
func (w *Wish) Update(ctx context.Context, client Client, wishID ...ID) (*Wish, error) {
	id := w.whichID(wishID...)
	return client.UpdateWish(ctx, id, w)
}

// UploadImage
func (w *Wish) UploadImage(ctx context.Context, client Client, file []byte, wishID ...ID) (*Wish, error) {
	id := w.whichID(wishID...)
	return client.UploadWishImage(ctx, id, file)
}

// UploadImageByFile
func (w *Wish) UploadImageByFile(ctx context.Context, client Client, filename string, wishID ...ID) (*Wish, error) {
	id := w.whichID(wishID...)
	file, err := os.ReadFile(filename)
	if err != nil {
		return nil, fmt.Errorf("failed to read file %s: %w", filename, err)
	}
	return client.UploadWishImage(ctx, id, file)
}
package koiApi

import (
	"context"
	"fmt"
	"os"
	"time"
)

// WishlistInterface defines methods for interacting with Wishlist resources.
type WishlistInterface interface {
	Create(ctx context.Context, client Client) (*Wishlist, error)                                               // HTTP POST /api/wishlists
	Delete(ctx context.Context, client Client, wishlistID ...ID) error                                          // HTTP DELETE /api/wishlists/{id}
	Get(ctx context.Context, client Client, wishlistID ...ID) (*Wishlist, error)                                // HTTP GET /api/wishlists/{id}
	GetParent(ctx context.Context, client Client, wishlistID ...ID) (*Wishlist, error)                          // HTTP GET /api/wishlists/{id}/parent
	IRI() string                                                                                                // /api/wishlists/{id}
	List(ctx context.Context, client Client) ([]*Wishlist, error)                                               // HTTP GET /api/wishlists
	ListChildren(ctx context.Context, client Client, wishlistID ...ID) ([]*Wishlist, error)                     // HTTP GET /api/wishlists/{id}/children
	ListWishes(ctx context.Context, client Client, wishlistID ...ID) ([]*Wish, error)                           // HTTP GET /api/wishlists/{id}/wishes
	Patch(ctx context.Context, client Client, wishlistID ...ID) (*Wishlist, error)                              // HTTP PATCH /api/wishlists/{id}
	Update(ctx context.Context, client Client, wishlistID ...ID) (*Wishlist, error)                             // HTTP PUT /api/wishlists/{id}
	UploadImage(ctx context.Context, client Client, file []byte, wishlistID ...ID) (*Wishlist, error)           // HTTP POST /api/wishlists/{id}/image
	UploadImageByFile(ctx context.Context, client Client, filename string, wishlistID ...ID) (*Wishlist, error) // HTTP POST /api/wishlists/{id}/image
}

// Wishlist represents a wishlist in Koillection, combining fields for JSON-LD and API interactions.
type Wishlist struct {
	Context          *Context   `json:"@context,omitempty" access:"rw"`         // JSON-LD only
	_ID              ID         `json:"@id,omitempty" access:"ro"`              // JSON-LD only
	Type             string     `json:"@type,omitempty" access:"rw"`            // JSON-LD only
	ID               ID         `json:"id,omitempty" access:"ro"`               // Identifier
	Name             string     `json:"name" access:"rw"`                       // Wishlist name
	Owner            *string    `json:"owner,omitempty" access:"ro"`            // Owner IRI
	Color            string     `json:"color" access:"ro"`                      // Color code
	Parent           *string    `json:"parent,omitempty" access:"rw"`           // Parent wishlist IRI
	Image            *string    `json:"image,omitempty" access:"ro"`            // Image URL
	SeenCounter      int        `json:"seenCounter,omitempty" access:"ro"`      // View count
	Visibility       Visibility `json:"visibility,omitempty" access:"rw"`       // Visibility level
	ParentVisibility *string    `json:"parentVisibility,omitempty" access:"ro"` // Parent visibility
	FinalVisibility  Visibility `json:"finalVisibility,omitempty" access:"ro"`  // Effective visibility
	CreatedAt        time.Time  `json:"createdAt" access:"ro"`                  // Creation timestamp
	UpdatedAt        *time.Time `json:"updatedAt,omitempty" access:"ro"`        // Update timestamp
	File             *string    `json:"file,omitempty" access:"wo"`             // Image file data
	DeleteImage      *bool      `json:"deleteImage,omitempty" access:"wo"`      // Flag to delete image
}

// whichID
func (w *Wishlist) whichID(wishlistID ...ID) ID {
	if len(wishlistID) > 0 {
		return wishlistID[0]
	}
	return w.ID
}

// Create
func (w *Wishlist) Create(ctx context.Context, client Client) (*Wishlist, error) {
	return client.CreateWishlist(ctx, w)
}

// Delete
func (w *Wishlist) Delete(ctx context.Context, client Client, wishlistID ...ID) error {
	id := w.whichID(wishlistID...)
	return client.DeleteWishlist(ctx, id)
}

// Get
func (w *Wishlist) Get(ctx context.Context, client Client, wishlistID ...ID) (*Wishlist, error) {
	id := w.whichID(wishlistID...)
	return client.GetWishlist(ctx, id)
}

// GetParent
func (w *Wishlist) GetParent(ctx context.Context, client Client, wishlistID ...ID) (*Wishlist, error) {
	id := w.whichID(wishlistID...)
	return client.GetWishlistParent(ctx, id)
}

// IRI
func (w *Wishlist) IRI() string {
	return fmt.Sprintf("/api/wishlists/%s", w.ID)
}

// List
func (w *Wishlist) List(ctx context.Context, client Client) ([]*Wishlist, error) {
	var allWishlists []*Wishlist
	for page := 1; ; page++ {
		wishlists, err := client.ListWishlists(ctx, page)
		if err != nil {
			return nil, fmt.Errorf("failed to list wishlists on page %d: %w", page, err)
		}
		if len(wishlists) == 0 {
			break
		}
		allWishlists = append(allWishlists, wishlists...)
	}
	return allWishlists, nil
}

// ListChildren
func (w *Wishlist) ListChildren(ctx context.Context, client Client, wishlistID ...ID) ([]*Wishlist, error) {
	id := w.whichID(wishlistID...)
	var allChildren []*Wishlist
	for page := 1; ; page++ {
		children, err := client.ListWishlistChildren(ctx, id, page)
		if err != nil {
			return nil, fmt.Errorf("failed to list child wishlists for ID %s on page %d: %w", id, page, err)
		}
		if len(children) == 0 {
			break
		}
		allChildren = append(allChildren, children...)
	}
	return allChildren, nil
}

// ListWishes
func (w *Wishlist) ListWishes(ctx context.Context, client Client, wishlistID ...ID) ([]*Wish, error) {
	id := w.whichID(wishlistID...)
	var allWishes []*Wish
	for page := 1; ; page++ {
		wishes, err := client.ListWishlistWishes(ctx, id, page)
		if err != nil {
			return nil, fmt.Errorf("failed to list wishes for ID %s on page %d: %w", id, page, err)
		}
		if len(wishes) == 0 {
			break
		}
		allWishes = append(allWishes, wishes...)
	}
	return allWishes, nil
}

// Patch
func (w *Wishlist) Patch(ctx context.Context, client Client, wishlistID ...ID) (*Wishlist, error) {
	id := w.whichID(wishlistID...)
	return client.PatchWishlist(ctx, id, w)
}

// Update
func (w *Wishlist) Update(ctx context.Context, client Client, wishlistID ...ID) (*Wishlist, error) {
	id := w.whichID(wishlistID...)
	return client.UpdateWishlist(ctx, id, w)
}

// UploadImage
func (w *Wishlist) UploadImage(ctx context.Context, client Client, file []byte, wishlistID ...ID) (*Wishlist, error) {
	id := w.whichID(wishlistID...)
	return client.UploadWishlistImage(ctx, id, file)
}

// UploadImageByFile
func (w *Wishlist) UploadImageByFile(ctx context.Context, client Client, filename string, wishlistID ...ID) (*Wishlist, error) {
	id := w.whichID(wishlistID...)
	file, err := os.ReadFile(filename)
	if err != nil {
		return nil, fmt.Errorf("failed to read file %s: %w", filename, err)
	}
	return client.UploadWishlistImage(ctx, id, file)
}
